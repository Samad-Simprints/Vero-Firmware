<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>dotstack API Reference: Audio/Video Distribution Protocol (AVDP)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dotstack API Reference
   &#160;<span id="projectnumber">1.8.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Audio/Video Distribution Protocol (AVDP)</div>  </div>
</div><!--header-->
<div class="contents">

<p>AVDTP is the transport protocol for audio and/or video distribution connections and streaming of audio or video media over the Bluetooth air interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__avdtp__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp__config.html">Configuration</a></td></tr>
<tr class="memdesc:group__avdtp__config"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module describes parameters used to configure AVDTP layer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bt__media__packet__t.html">bt_media_packet_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media packet buffer.  <a href="struct__bt__media__packet__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SEP capabilities.  <a href="structbt__avdtp__sep__capabilities__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bt__avdtp__sep__t.html">bt_avdtp_sep_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SEP description.  <a href="struct__bt__avdtp__sep__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__ctrl__channel__connected__t.html">bt_avdtp_evt_ctrl_channel_connected_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_CTRL_CHANNEL_CONNECTED event.  <a href="structbt__avdtp__evt__ctrl__channel__connected__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__ctrl__channel__disconnected__t.html">bt_avdtp_evt_ctrl_channel_disconnected_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED event.  <a href="structbt__avdtp__evt__ctrl__channel__disconnected__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__discover__completed__t.html">bt_avdtp_evt_discover_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_DISCOVER_COMPLETED event.  <a href="structbt__avdtp__evt__discover__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__sep__info__received__t.html">bt_avdtp_evt_sep_info_received_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SEP_INFO_RECEIVED event.  <a href="structbt__avdtp__evt__sep__info__received__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__get__sep__capabilities__completed__t.html">bt_avdtp_evt_get_sep_capabilities_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED event.  <a href="structbt__avdtp__evt__get__sep__capabilities__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__sep__capabilities__received__t.html">bt_avdtp_evt_sep_capabilities_received_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SEP_CAPABILITIES_RECEIVED and AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED events.  <a href="structbt__avdtp__evt__sep__capabilities__received__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__set__stream__configuration__completed__t.html">bt_avdtp_evt_set_stream_configuration_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event.  <a href="structbt__avdtp__evt__set__stream__configuration__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__get__stream__configuration__completed__t.html">bt_avdtp_evt_get_stream_configuration_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event.  <a href="structbt__avdtp__evt__get__stream__configuration__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__reconfigure__completed__t.html">bt_avdtp_evt_stream_reconfigure_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED event.  <a href="structbt__avdtp__evt__stream__reconfigure__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__open__stream__completed__t.html">bt_avdtp_evt_open_stream_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_OPEN_STREAM_COMPLETED event.  <a href="structbt__avdtp__evt__open__stream__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__start__stream__completed__t.html">bt_avdtp_evt_start_stream_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_START_STREAM_COMPLETED event.  <a href="structbt__avdtp__evt__start__stream__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__close__stream__completed__t.html">bt_avdtp_evt_close_stream_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_CLOSE_STREAM_COMPLETED event.  <a href="structbt__avdtp__evt__close__stream__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__suspend__stream__completed__t.html">bt_avdtp_evt_suspend_stream_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SUSPEND_STREAM_COMPLETED event.  <a href="structbt__avdtp__evt__suspend__stream__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__security__control__completed__t.html">bt_avdtp_evt_stream_security_control_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED event.  <a href="structbt__avdtp__evt__stream__security__control__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__set__stream__configuration__requested__t.html">bt_avdtp_evt_set_stream_configuration_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED event.  <a href="structbt__avdtp__evt__set__stream__configuration__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__reconfigure__stream__requested__t.html">bt_avdtp_evt_reconfigure_stream_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED event.  <a href="structbt__avdtp__evt__reconfigure__stream__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__open__stream__requested__t.html">bt_avdtp_evt_open_stream_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_OPEN_STREAM_REQUESTED event.  <a href="structbt__avdtp__evt__open__stream__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__start__stream__requested__t.html">bt_avdtp_evt_start_stream_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_START_STREAM_REQUESTED event.  <a href="structbt__avdtp__evt__start__stream__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__suspend__stream__requested__t.html">bt_avdtp_evt_suspend_stream_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_SUSPEND_STREAM_REQUESTED event.  <a href="structbt__avdtp__evt__suspend__stream__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__close__stream__requested__t.html">bt_avdtp_evt_close_stream_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_CLOSE_STREAM_REQUESTED event.  <a href="structbt__avdtp__evt__close__stream__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__abort__stream__requested__t.html">bt_avdtp_evt_abort_stream_requested_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_ABORT_STREAM_REQUESTED event.  <a href="structbt__avdtp__evt__abort__stream__requested__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__delay__report__completed__t.html">bt_avdtp_evt_delay_report_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_DELAYREPORT_COMPLETED event.  <a href="structbt__avdtp__evt__delay__report__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__configured__t.html">bt_avdtp_evt_stream_configured_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_CONFIGURED event.  <a href="structbt__avdtp__evt__stream__configured__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__reconfigured__t.html">bt_avdtp_evt_stream_reconfigured_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_RECONFIGURED event.  <a href="structbt__avdtp__evt__stream__reconfigured__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__opened__t.html">bt_avdtp_evt_stream_opened_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_OPENED event.  <a href="structbt__avdtp__evt__stream__opened__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__started__t.html">bt_avdtp_evt_stream_started_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_STARTED event.  <a href="structbt__avdtp__evt__stream__started__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__suspended__t.html">bt_avdtp_evt_stream_suspended_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_SUSPENDED event.  <a href="structbt__avdtp__evt__stream__suspended__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__closed__t.html">bt_avdtp_evt_stream_closed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_CLOSED event.  <a href="structbt__avdtp__evt__stream__closed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__stream__aborted__t.html">bt_avdtp_evt_stream_aborted_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_STREAM_ABORTED event.  <a href="structbt__avdtp__evt__stream__aborted__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__media__packet__received__t.html">bt_avdtp_evt_media_packet_received_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_MEDIA_PACKET_RECEIVED event.  <a href="structbt__avdtp__evt__media__packet__received__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__media__packet__sent__t.html">bt_avdtp_evt_media_packet_sent_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_MEDIA_PACKET_SENT event.  <a href="structbt__avdtp__evt__media__packet__sent__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__evt__media__packet__send__failed__t.html">bt_avdtp_evt_media_packet_send_failed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_EVT_MEDIA_PACKET_SEND_FAILED event.  <a href="structbt__avdtp__evt__media__packet__send__failed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionbt__avdtp__event__t.html">bt_avdtp_event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to an application callback.  <a href="unionbt__avdtp__event__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__transport__channel__t.html">bt_avdtp_transport_channel_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport channel description.  <a href="structbt__avdtp__transport__channel__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__transport__session__t.html">bt_avdtp_transport_session_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport session description.  <a href="structbt__avdtp__transport__session__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__stream__t.html">bt_avdtp_stream_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream description.  <a href="structbt__avdtp__stream__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__codec__t.html">bt_avdtp_codec_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codec handler description.  <a href="structbt__avdtp__codec__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__codec__op__parse__config__t.html">bt_avdtp_codec_op_parse_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_CODEC_OPCODE_PARSE_CONFIG operation.  <a href="structbt__avdtp__codec__op__parse__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__codec__op__serialize__config__t.html">bt_avdtp_codec_op_serialize_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to AVDTP_CODEC_OPCODE_SERIALIZE_CONFIG operation.  <a href="structbt__avdtp__codec__op__serialize__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union__bt__avdtp__codec__op__param__u.html">bt_avdtp_codec_op_param_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to a codec handler.  <a href="union__bt__avdtp__codec__op__param__u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVDTP manager.  <a href="structbt__avdtp__mgr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadc565b71c9d76e8a3c6c838436605b83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gadc565b71c9d76e8a3c6c838436605b83">bt_avdtp_connect</a>(mgr,  remote_addr)&#160;&#160;&#160;_bt_avdtp_open_control_channel_ex(mgr, remote_addr, HCI_CONFIG_ENABLE_AUTHENTICATION | HCI_CONFIG_ENABLE_ENCRYPTION)</td></tr>
<tr class="memdesc:gadc565b71c9d76e8a3c6c838436605b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote device.  <a href="#gadc565b71c9d76e8a3c6c838436605b83">More...</a><br /></td></tr>
<tr class="separator:gadc565b71c9d76e8a3c6c838436605b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258c796e3a420d6fc29d10035fe47cd9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga258c796e3a420d6fc29d10035fe47cd9">bt_avdtp_connect_ex</a>(mgr,  remote_addr,  acl_config)&#160;&#160;&#160;_bt_avdtp_open_control_channel_ex(mgr, remote_addr, acl_config)</td></tr>
<tr class="memdesc:ga258c796e3a420d6fc29d10035fe47cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote device.  <a href="#ga258c796e3a420d6fc29d10035fe47cd9">More...</a><br /></td></tr>
<tr class="separator:ga258c796e3a420d6fc29d10035fe47cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gace691b5255436e9b09a3d18b23e33395"><td class="memItemLeft" align="right" valign="top">typedef bt_byte(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gace691b5255436e9b09a3d18b23e33395">bt_avdtp_codec_handler_fp</a>) (struct _bt_avdtp_codec_t *codec, bt_byte opcode, bt_avdtp_codec_op_param_t *op_param, struct _bt_avdtp_mgr_t *mgr)</td></tr>
<tr class="memdesc:gace691b5255436e9b09a3d18b23e33395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codec handler.  <a href="#gace691b5255436e9b09a3d18b23e33395">More...</a><br /></td></tr>
<tr class="separator:gace691b5255436e9b09a3d18b23e33395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d105a7645343cec9c5da702afaa844"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad2d105a7645343cec9c5da702afaa844">bt_avdtp_mgr_callback_fp</a>) (struct _bt_avdtp_mgr_t *mgr, bt_byte evt, <a class="el" href="unionbt__avdtp__event__t.html">bt_avdtp_event_t</a> *evt_param, void *callback_param)</td></tr>
<tr class="memdesc:gad2d105a7645343cec9c5da702afaa844"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVDTP application callback.  <a href="#gad2d105a7645343cec9c5da702afaa844">More...</a><br /></td></tr>
<tr class="separator:gad2d105a7645343cec9c5da702afaa844"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9d6fcf341f66d243d5381c12c47eb7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga9d6fcf341f66d243d5381c12c47eb7b7">bt_avdtp_get_mgr</a> (void)</td></tr>
<tr class="memdesc:ga9d6fcf341f66d243d5381c12c47eb7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an instance of the AVDTP manager.  <a href="#ga9d6fcf341f66d243d5381c12c47eb7b7">More...</a><br /></td></tr>
<tr class="separator:ga9d6fcf341f66d243d5381c12c47eb7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265589188d09517322530a2933850acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga265589188d09517322530a2933850acf">bt_avdtp_init</a> (void)</td></tr>
<tr class="memdesc:ga265589188d09517322530a2933850acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the AVDTP layer.  <a href="#ga265589188d09517322530a2933850acf">More...</a><br /></td></tr>
<tr class="separator:ga265589188d09517322530a2933850acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274a948661f9e1902278a76b8259ea94"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga274a948661f9e1902278a76b8259ea94">bt_avdtp_start</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr)</td></tr>
<tr class="memdesc:ga274a948661f9e1902278a76b8259ea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the AVDTP layer.  <a href="#ga274a948661f9e1902278a76b8259ea94">More...</a><br /></td></tr>
<tr class="separator:ga274a948661f9e1902278a76b8259ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a41da0e2cb8e036e4598ee2cd1340fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5a41da0e2cb8e036e4598ee2cd1340fb">bt_avdtp_register_callback</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, <a class="el" href="group__avdtp.html#gad2d105a7645343cec9c5da702afaa844">bt_avdtp_mgr_callback_fp</a> callback, void *callback_param)</td></tr>
<tr class="memdesc:ga5a41da0e2cb8e036e4598ee2cd1340fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a AVDTP application callback.  <a href="#ga5a41da0e2cb8e036e4598ee2cd1340fb">More...</a><br /></td></tr>
<tr class="separator:ga5a41da0e2cb8e036e4598ee2cd1340fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc5552470ee84924d0e5fe300e1ef67"><td class="memItemLeft" align="right" valign="top">bt_byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga8fc5552470ee84924d0e5fe300e1ef67">bt_avdtp_register_sep</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte type, const <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *caps)</td></tr>
<tr class="memdesc:ga8fc5552470ee84924d0e5fe300e1ef67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a SEP with the local AVDTP manager.  <a href="#ga8fc5552470ee84924d0e5fe300e1ef67">More...</a><br /></td></tr>
<tr class="separator:ga8fc5552470ee84924d0e5fe300e1ef67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3326bc00ab3d922aeb8771b0ca6206f8"><td class="memItemLeft" align="right" valign="top">bt_avdtp_sep_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3326bc00ab3d922aeb8771b0ca6206f8">bt_avdtp_get_sep</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte sep_id)</td></tr>
<tr class="memdesc:ga3326bc00ab3d922aeb8771b0ca6206f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a SEP info by its ID.  <a href="#ga3326bc00ab3d922aeb8771b0ca6206f8">More...</a><br /></td></tr>
<tr class="separator:ga3326bc00ab3d922aeb8771b0ca6206f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7b41ff858c3930e8280d76dbbed835"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga2d7b41ff858c3930e8280d76dbbed835">bt_avdtp_disconnect</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_bdaddr_t *remote_addr)</td></tr>
<tr class="memdesc:ga2d7b41ff858c3930e8280d76dbbed835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from a remote device.  <a href="#ga2d7b41ff858c3930e8280d76dbbed835">More...</a><br /></td></tr>
<tr class="separator:ga2d7b41ff858c3930e8280d76dbbed835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3da0a9fa37246063d5f7c9688f9df4"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7d3da0a9fa37246063d5f7c9688f9df4">bt_avdtp_discover</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_bdaddr_t *remote_addr)</td></tr>
<tr class="memdesc:ga7d3da0a9fa37246063d5f7c9688f9df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover SEPs on a remote device.  <a href="#ga7d3da0a9fa37246063d5f7c9688f9df4">More...</a><br /></td></tr>
<tr class="separator:ga7d3da0a9fa37246063d5f7c9688f9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac43ab93b9bbfc44adb11d00432cac8"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gadac43ab93b9bbfc44adb11d00432cac8">bt_avdtp_get_capabilities</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_bdaddr_t *remote_addr, bt_byte seid_acp)</td></tr>
<tr class="memdesc:gadac43ab93b9bbfc44adb11d00432cac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remote SEP capabilities.  <a href="#gadac43ab93b9bbfc44adb11d00432cac8">More...</a><br /></td></tr>
<tr class="separator:gadac43ab93b9bbfc44adb11d00432cac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92da4c6c289f244cc2d797dd20a4ce93"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga92da4c6c289f244cc2d797dd20a4ce93">bt_avdtp_get_all_capabilities</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_bdaddr_t *remote_addr, bt_byte seid_acp)</td></tr>
<tr class="memdesc:ga92da4c6c289f244cc2d797dd20a4ce93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remote SEP capabilities.  <a href="#ga92da4c6c289f244cc2d797dd20a4ce93">More...</a><br /></td></tr>
<tr class="separator:ga92da4c6c289f244cc2d797dd20a4ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab49d03d6642d60ee5bb8628d1e96a088"><td class="memItemLeft" align="right" valign="top">bt_byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab49d03d6642d60ee5bb8628d1e96a088">bt_avdtp_create_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr)</td></tr>
<tr class="memdesc:gab49d03d6642d60ee5bb8628d1e96a088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream.  <a href="#gab49d03d6642d60ee5bb8628d1e96a088">More...</a><br /></td></tr>
<tr class="separator:gab49d03d6642d60ee5bb8628d1e96a088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90fbc2862c2220022f113512b97e2be"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad90fbc2862c2220022f113512b97e2be">bt_avdtp_destroy_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gad90fbc2862c2220022f113512b97e2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a stream.  <a href="#gad90fbc2862c2220022f113512b97e2be">More...</a><br /></td></tr>
<tr class="separator:gad90fbc2862c2220022f113512b97e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac078d38da081ad5112b5992c66c37c9f"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac078d38da081ad5112b5992c66c37c9f">bt_avdtp_listen</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_byte sep_id)</td></tr>
<tr class="memdesc:gac078d38da081ad5112b5992c66c37c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for incoming connections.  <a href="#gac078d38da081ad5112b5992c66c37c9f">More...</a><br /></td></tr>
<tr class="separator:gac078d38da081ad5112b5992c66c37c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5030fc428a0d8245d7f725414443ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5f5030fc428a0d8245d7f725414443ec">bt_avdtp_cancel_listen</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_byte sep_id)</td></tr>
<tr class="memdesc:ga5f5030fc428a0d8245d7f725414443ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel listening for incoming connections.  <a href="#ga5f5030fc428a0d8245d7f725414443ec">More...</a><br /></td></tr>
<tr class="separator:ga5f5030fc428a0d8245d7f725414443ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75052b1810022b4aa5a9b61f8789080"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad75052b1810022b4aa5a9b61f8789080">bt_avdtp_set_configuration</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_bdaddr_t *remote_addr, bt_byte seid_int, bt_byte seid_acp, const <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *caps)</td></tr>
<tr class="memdesc:gad75052b1810022b4aa5a9b61f8789080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stream configuration.  <a href="#gad75052b1810022b4aa5a9b61f8789080">More...</a><br /></td></tr>
<tr class="separator:gad75052b1810022b4aa5a9b61f8789080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e4c361ffa8d06e04502c9a8332e7c1"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf3e4c361ffa8d06e04502c9a8332e7c1">bt_avdtp_get_configuration</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gaf3e4c361ffa8d06e04502c9a8332e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream configuration.  <a href="#gaf3e4c361ffa8d06e04502c9a8332e7c1">More...</a><br /></td></tr>
<tr class="separator:gaf3e4c361ffa8d06e04502c9a8332e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d853c711364c8f50f2d29a758cffcf"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac3d853c711364c8f50f2d29a758cffcf">bt_avdtp_reconfigure_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *caps)</td></tr>
<tr class="memdesc:gac3d853c711364c8f50f2d29a758cffcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure stream.  <a href="#gac3d853c711364c8f50f2d29a758cffcf">More...</a><br /></td></tr>
<tr class="separator:gac3d853c711364c8f50f2d29a758cffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed4fd0933472235f2ffa1594daccde7c"><td class="memItemLeft" align="right" valign="top">bt_byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaed4fd0933472235f2ffa1594daccde7c">bt_avdtp_get_stream_state</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gaed4fd0933472235f2ffa1594daccde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local stream state.  <a href="#gaed4fd0933472235f2ffa1594daccde7c">More...</a><br /></td></tr>
<tr class="separator:gaed4fd0933472235f2ffa1594daccde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ba4a1f9d3a9d91268cf66aa9afd589"><td class="memItemLeft" align="right" valign="top">bt_byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gae3ba4a1f9d3a9d91268cf66aa9afd589">bt_avdtp_get_stream_local_sep_id</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gae3ba4a1f9d3a9d91268cf66aa9afd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's local SEP ID.  <a href="#gae3ba4a1f9d3a9d91268cf66aa9afd589">More...</a><br /></td></tr>
<tr class="separator:gae3ba4a1f9d3a9d91268cf66aa9afd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7135cde7501a2ec46b2921169b68599"><td class="memItemLeft" align="right" valign="top">bt_byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaa7135cde7501a2ec46b2921169b68599">bt_avdtp_get_stream_remote_sep_id</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gaa7135cde7501a2ec46b2921169b68599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's remote SEP ID.  <a href="#gaa7135cde7501a2ec46b2921169b68599">More...</a><br /></td></tr>
<tr class="separator:gaa7135cde7501a2ec46b2921169b68599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67ac3b6a1501e1cba70af33172dfa1a"><td class="memItemLeft" align="right" valign="top">bt_bdaddr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab67ac3b6a1501e1cba70af33172dfa1a">bt_avdtp_get_stream_remote_address</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gab67ac3b6a1501e1cba70af33172dfa1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's remote BT address.  <a href="#gab67ac3b6a1501e1cba70af33172dfa1a">More...</a><br /></td></tr>
<tr class="separator:gab67ac3b6a1501e1cba70af33172dfa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450ff68934f53a6c2ddaeb0cca29fab7"><td class="memItemLeft" align="right" valign="top">bt_byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga450ff68934f53a6c2ddaeb0cca29fab7">bt_avdtp_get_stream_codec_type</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:ga450ff68934f53a6c2ddaeb0cca29fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the codec currently used with the stream.  <a href="#ga450ff68934f53a6c2ddaeb0cca29fab7">More...</a><br /></td></tr>
<tr class="separator:ga450ff68934f53a6c2ddaeb0cca29fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade095bf025f9fb35c93613ecf758ce02"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gade095bf025f9fb35c93613ecf758ce02">bt_avdtp_get_stream_codec_config</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gade095bf025f9fb35c93613ecf758ce02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configuration of the codec currently used with the stream.  <a href="#gade095bf025f9fb35c93613ecf758ce02">More...</a><br /></td></tr>
<tr class="separator:gade095bf025f9fb35c93613ecf758ce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399121298592a0f75073b437e0dfd6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga399121298592a0f75073b437e0dfd6c0">bt_avdtp_get_stream_config</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:ga399121298592a0f75073b437e0dfd6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's configuration.  <a href="#ga399121298592a0f75073b437e0dfd6c0">More...</a><br /></td></tr>
<tr class="separator:ga399121298592a0f75073b437e0dfd6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae826060d50bea1cea37e02cb899af46f"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gae826060d50bea1cea37e02cb899af46f">bt_avdtp_open_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gae826060d50bea1cea37e02cb899af46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stream.  <a href="#gae826060d50bea1cea37e02cb899af46f">More...</a><br /></td></tr>
<tr class="separator:gae826060d50bea1cea37e02cb899af46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae463a1e025414d880c758865b5d34443"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gae463a1e025414d880c758865b5d34443">bt_avdtp_start_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gae463a1e025414d880c758865b5d34443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a stream.  <a href="#gae463a1e025414d880c758865b5d34443">More...</a><br /></td></tr>
<tr class="separator:gae463a1e025414d880c758865b5d34443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa183c4355d28d15e938a4a088c7a77fd"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaa183c4355d28d15e938a4a088c7a77fd">bt_avdtp_close_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gaa183c4355d28d15e938a4a088c7a77fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a stream.  <a href="#gaa183c4355d28d15e938a4a088c7a77fd">More...</a><br /></td></tr>
<tr class="separator:gaa183c4355d28d15e938a4a088c7a77fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad180fe6c3657b0fc2367faaf33146e80"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad180fe6c3657b0fc2367faaf33146e80">bt_avdtp_suspend_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gad180fe6c3657b0fc2367faaf33146e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a stream.  <a href="#gad180fe6c3657b0fc2367faaf33146e80">More...</a><br /></td></tr>
<tr class="separator:gad180fe6c3657b0fc2367faaf33146e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2882c4e47b122d8f26fd505bbf5f8a"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3b2882c4e47b122d8f26fd505bbf5f8a">bt_avdtp_abort_stream</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:ga3b2882c4e47b122d8f26fd505bbf5f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a stream.  <a href="#ga3b2882c4e47b122d8f26fd505bbf5f8a">More...</a><br /></td></tr>
<tr class="separator:ga3b2882c4e47b122d8f26fd505bbf5f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06ed7034f7742a739de18472f88b99d"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab06ed7034f7742a739de18472f88b99d">bt_avdtp_security_control</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_byte *sc_data, bt_byte sc_data_len)</td></tr>
<tr class="memdesc:gab06ed7034f7742a739de18472f88b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange content protection control data.  <a href="#gab06ed7034f7742a739de18472f88b99d">More...</a><br /></td></tr>
<tr class="separator:gab06ed7034f7742a739de18472f88b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2895ca6383742f0df37422ac6fb3652"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf2895ca6383742f0df37422ac6fb3652">bt_avdtp_report_delay</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_uint delay)</td></tr>
<tr class="memdesc:gaf2895ca6383742f0df37422ac6fb3652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report delay value of a Sink to a Source.  <a href="#gaf2895ca6383742f0df37422ac6fb3652">More...</a><br /></td></tr>
<tr class="separator:gaf2895ca6383742f0df37422ac6fb3652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b9313048cf22068276f9dc5505debb"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga35b9313048cf22068276f9dc5505debb">bt_avdtp_register_codec</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, <a class="el" href="structbt__avdtp__codec__t.html">bt_avdtp_codec_t</a> *codec)</td></tr>
<tr class="memdesc:ga35b9313048cf22068276f9dc5505debb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a codec.  <a href="#ga35b9313048cf22068276f9dc5505debb">More...</a><br /></td></tr>
<tr class="separator:ga35b9313048cf22068276f9dc5505debb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e53a1c3a158967a2d15a61e6e25546"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga38e53a1c3a158967a2d15a61e6e25546">bt_avdtp_unregister_codec</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte codec_type)</td></tr>
<tr class="memdesc:ga38e53a1c3a158967a2d15a61e6e25546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a codec.  <a href="#ga38e53a1c3a158967a2d15a61e6e25546">More...</a><br /></td></tr>
<tr class="separator:ga38e53a1c3a158967a2d15a61e6e25546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9663f6647cd82a7afa2fbc0f40df9571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbt__avdtp__codec__t.html">bt_avdtp_codec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga9663f6647cd82a7afa2fbc0f40df9571">bt_avdtp_find_codec</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte codec_type)</td></tr>
<tr class="memdesc:ga9663f6647cd82a7afa2fbc0f40df9571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a codec.  <a href="#ga9663f6647cd82a7afa2fbc0f40df9571">More...</a><br /></td></tr>
<tr class="separator:ga9663f6647cd82a7afa2fbc0f40df9571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae73bd76bdea0c11165e3ababce488e4"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaae73bd76bdea0c11165e3ababce488e4">bt_avdtp_add_media_rx_buffer</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_media_packet_t *buffer)</td></tr>
<tr class="memdesc:gaae73bd76bdea0c11165e3ababce488e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a media packet buffer to a receive queue.  <a href="#gaae73bd76bdea0c11165e3ababce488e4">More...</a><br /></td></tr>
<tr class="separator:gaae73bd76bdea0c11165e3ababce488e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ac93f097aa119c492c1e82bdb083bf"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga30ac93f097aa119c492c1e82bdb083bf">bt_avdtp_remove_media_rx_buffer</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_media_packet_t *buffer)</td></tr>
<tr class="memdesc:ga30ac93f097aa119c492c1e82bdb083bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a media packet buffer from a receive queue.  <a href="#ga30ac93f097aa119c492c1e82bdb083bf">More...</a><br /></td></tr>
<tr class="separator:ga30ac93f097aa119c492c1e82bdb083bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563a397fc0ec80d6dcd7f93c5ea4c9d8"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga563a397fc0ec80d6dcd7f93c5ea4c9d8">bt_avdtp_add_media_tx_buffer</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_media_packet_t *buffer)</td></tr>
<tr class="memdesc:ga563a397fc0ec80d6dcd7f93c5ea4c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a media packet buffer to a send queue.  <a href="#ga563a397fc0ec80d6dcd7f93c5ea4c9d8">More...</a><br /></td></tr>
<tr class="separator:ga563a397fc0ec80d6dcd7f93c5ea4c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfff55df797f6d235f9ad5a8313a608"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3cfff55df797f6d235f9ad5a8313a608">bt_avdtp_remove_media_tx_buffer</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle, bt_media_packet_t *buffer)</td></tr>
<tr class="memdesc:ga3cfff55df797f6d235f9ad5a8313a608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a media packet buffer from a send queue.  <a href="#ga3cfff55df797f6d235f9ad5a8313a608">More...</a><br /></td></tr>
<tr class="separator:ga3cfff55df797f6d235f9ad5a8313a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb053fd416a62a4ef9ccc9d591aca6c2"><td class="memItemLeft" align="right" valign="top">bt_hci_conn_state_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaeb053fd416a62a4ef9ccc9d591aca6c2">bt_avdtp_get_hci_connection</a> (<a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *mgr, bt_byte strm_handle)</td></tr>
<tr class="memdesc:gaeb053fd416a62a4ef9ccc9d591aca6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get HCI connection for a stream.  <a href="#gaeb053fd416a62a4ef9ccc9d591aca6c2">More...</a><br /></td></tr>
<tr class="separator:gaeb053fd416a62a4ef9ccc9d591aca6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Events</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp87f9f735a1d36793ceaecd4e47124b63"></a>The following is a list of events AVDTP layer generates and can report to the upper layer when it completes executing an operation initiated by either local or remote device. </p>
</td></tr>
<tr class="memitem:ga487bc0f44a77b71894465a0e86af8e2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga487bc0f44a77b71894465a0e86af8e2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga487bc0f44a77b71894465a0e86af8e2e">AVDTP_EVT_CTRL_CHANNEL_CONNECTED</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga487bc0f44a77b71894465a0e86af8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a control channel between two AVDTP entities has been established. <br /></td></tr>
<tr class="separator:ga487bc0f44a77b71894465a0e86af8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d7a0213d056ec3dbf7f57a93e2b528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2d7a0213d056ec3dbf7f57a93e2b528"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac2d7a0213d056ec3dbf7f57a93e2b528">AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gac2d7a0213d056ec3dbf7f57a93e2b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a control channel between two AVDTP entities has been terminated. <br /></td></tr>
<tr class="separator:gac2d7a0213d056ec3dbf7f57a93e2b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bcaad109a3f543f2967a6b54323715"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga63bcaad109a3f543f2967a6b54323715"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga63bcaad109a3f543f2967a6b54323715">AVDTP_EVT_CTRL_CONNECTION_FAILED</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga63bcaad109a3f543f2967a6b54323715"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device failed to create a control channel between two AVDTP entities. <br /></td></tr>
<tr class="separator:ga63bcaad109a3f543f2967a6b54323715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cacb1c59c0f81b6e2d99e115663620"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97cacb1c59c0f81b6e2d99e115663620"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga97cacb1c59c0f81b6e2d99e115663620">AVDTP_EVT_DISCOVER_COMPLETED</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga97cacb1c59c0f81b6e2d99e115663620"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "discover" request. <br /></td></tr>
<tr class="separator:ga97cacb1c59c0f81b6e2d99e115663620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d9212f94534842dcbb45cd31165bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0d9212f94534842dcbb45cd31165bb2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaa0d9212f94534842dcbb45cd31165bb2">AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:gaa0d9212f94534842dcbb45cd31165bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "get SEP capabilities" request. <br /></td></tr>
<tr class="separator:gaa0d9212f94534842dcbb45cd31165bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5746451b5464681c2647b3759fede77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5746451b5464681c2647b3759fede77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac5746451b5464681c2647b3759fede77">AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:gac5746451b5464681c2647b3759fede77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "set stream configuration" request. <br /></td></tr>
<tr class="separator:gac5746451b5464681c2647b3759fede77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b70889dd53eef85eb7f9544e96defe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b70889dd53eef85eb7f9544e96defe8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga6b70889dd53eef85eb7f9544e96defe8">AVDTP_EVT_GET_STREAM_CONFIGURATION_COMPLETED</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:ga6b70889dd53eef85eb7f9544e96defe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "get stream configuration" request. <br /></td></tr>
<tr class="separator:ga6b70889dd53eef85eb7f9544e96defe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c6c2394d3fc63950125d13336ab888"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5c6c2394d3fc63950125d13336ab888"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab5c6c2394d3fc63950125d13336ab888">AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:gab5c6c2394d3fc63950125d13336ab888"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "change stream configuration" request. <br /></td></tr>
<tr class="separator:gab5c6c2394d3fc63950125d13336ab888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad709ebeea699c1528781dea4dbd828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ad709ebeea699c1528781dea4dbd828"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga4ad709ebeea699c1528781dea4dbd828">AVDTP_EVT_OPEN_STREAM_COMPLETED</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:ga4ad709ebeea699c1528781dea4dbd828"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "open stream" request. <br /></td></tr>
<tr class="separator:ga4ad709ebeea699c1528781dea4dbd828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad43101d6b56f2a60a1e4b9fa7af5e484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad43101d6b56f2a60a1e4b9fa7af5e484"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad43101d6b56f2a60a1e4b9fa7af5e484">AVDTP_EVT_START_STREAM_COMPLETED</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:gad43101d6b56f2a60a1e4b9fa7af5e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "start stream" request. <br /></td></tr>
<tr class="separator:gad43101d6b56f2a60a1e4b9fa7af5e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29531d2b1322305df3a053e9971a55d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29531d2b1322305df3a053e9971a55d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga29531d2b1322305df3a053e9971a55d3">AVDTP_EVT_CLOSE_STREAM_COMPLETED</a>&#160;&#160;&#160;11</td></tr>
<tr class="memdesc:ga29531d2b1322305df3a053e9971a55d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "close stream" request. <br /></td></tr>
<tr class="separator:ga29531d2b1322305df3a053e9971a55d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754b6c1ad22364cbd538922a148490f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga754b6c1ad22364cbd538922a148490f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga754b6c1ad22364cbd538922a148490f3">AVDTP_EVT_SUSPEND_STREAM_COMPLETED</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:ga754b6c1ad22364cbd538922a148490f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "suspend stream" request. <br /></td></tr>
<tr class="separator:ga754b6c1ad22364cbd538922a148490f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275faa00a9661ac03a4b879f3155567b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga275faa00a9661ac03a4b879f3155567b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga275faa00a9661ac03a4b879f3155567b">AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:ga275faa00a9661ac03a4b879f3155567b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "exchange content protection control data" request. <br /></td></tr>
<tr class="separator:ga275faa00a9661ac03a4b879f3155567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac924f50164e6d7fd4478a5dc5d10ba71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac924f50164e6d7fd4478a5dc5d10ba71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac924f50164e6d7fd4478a5dc5d10ba71">AVDTP_EVT_ABORT_STREAM_COMPLETED</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:gac924f50164e6d7fd4478a5dc5d10ba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "abort stream" request. <br /></td></tr>
<tr class="separator:gac924f50164e6d7fd4478a5dc5d10ba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984ef1c88a76945564e7ecea7d13657b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga984ef1c88a76945564e7ecea7d13657b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga984ef1c88a76945564e7ecea7d13657b">AVDTP_EVT_SEP_INFO_RECEIVED</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:ga984ef1c88a76945564e7ecea7d13657b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated for each SEP contained in a positive response to a "discover" request. <br /></td></tr>
<tr class="separator:ga984ef1c88a76945564e7ecea7d13657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3c334e2d7f5e1c877379243200767d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c3c334e2d7f5e1c877379243200767d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7c3c334e2d7f5e1c877379243200767d">AVDTP_EVT_SEP_CAPABILITIES_RECEIVED</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga7c3c334e2d7f5e1c877379243200767d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a positive response to a "get SEP capabilities" request. <br /></td></tr>
<tr class="separator:ga7c3c334e2d7f5e1c877379243200767d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b941fe0c3d0a5064f65c1aa9e97be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37b941fe0c3d0a5064f65c1aa9e97be3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga37b941fe0c3d0a5064f65c1aa9e97be3">AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED</a>&#160;&#160;&#160;17</td></tr>
<tr class="memdesc:ga37b941fe0c3d0a5064f65c1aa9e97be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a positive response to a "get stream configuration" request. <br /></td></tr>
<tr class="separator:ga37b941fe0c3d0a5064f65c1aa9e97be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c53e62ac8683eecc942a1d541488477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3c53e62ac8683eecc942a1d541488477"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3c53e62ac8683eecc942a1d541488477">AVDTP_EVT_DELAYREPORT_COMPLETED</a>&#160;&#160;&#160;18</td></tr>
<tr class="memdesc:ga3c53e62ac8683eecc942a1d541488477"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "delay report" request. <br /></td></tr>
<tr class="separator:ga3c53e62ac8683eecc942a1d541488477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8bd4fadade17f21abd71c7db4fff1d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8bd4fadade17f21abd71c7db4fff1d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaa8bd4fadade17f21abd71c7db4fff1d9">AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED</a>&#160;&#160;&#160;50</td></tr>
<tr class="memdesc:gaa8bd4fadade17f21abd71c7db4fff1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "set stream configuration" request. <br /></td></tr>
<tr class="separator:gaa8bd4fadade17f21abd71c7db4fff1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9fbffe93347d536c2e3d11a8b02fb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb9fbffe93347d536c2e3d11a8b02fb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaeb9fbffe93347d536c2e3d11a8b02fb3">AVDTP_EVT_OPEN_STREAM_REQUESTED</a>&#160;&#160;&#160;51</td></tr>
<tr class="memdesc:gaeb9fbffe93347d536c2e3d11a8b02fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "open stream" request. <br /></td></tr>
<tr class="separator:gaeb9fbffe93347d536c2e3d11a8b02fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d8f1ef04ce43f994dc05bc833f2603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12d8f1ef04ce43f994dc05bc833f2603"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga12d8f1ef04ce43f994dc05bc833f2603">AVDTP_EVT_START_STREAM_REQUESTED</a>&#160;&#160;&#160;52</td></tr>
<tr class="memdesc:ga12d8f1ef04ce43f994dc05bc833f2603"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "start stream" request. <br /></td></tr>
<tr class="separator:ga12d8f1ef04ce43f994dc05bc833f2603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691b824e56e1b955c12df4580b75417f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga691b824e56e1b955c12df4580b75417f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga691b824e56e1b955c12df4580b75417f">AVDTP_EVT_CLOSE_STREAM_REQUESTED</a>&#160;&#160;&#160;53</td></tr>
<tr class="memdesc:ga691b824e56e1b955c12df4580b75417f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "close stream" request. <br /></td></tr>
<tr class="separator:ga691b824e56e1b955c12df4580b75417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15b9087ffa5bd436754de42bde45193"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf15b9087ffa5bd436754de42bde45193"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf15b9087ffa5bd436754de42bde45193">AVDTP_EVT_SUSPEND_STREAM_REQUESTED</a>&#160;&#160;&#160;54</td></tr>
<tr class="memdesc:gaf15b9087ffa5bd436754de42bde45193"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "suspend stream" request. <br /></td></tr>
<tr class="separator:gaf15b9087ffa5bd436754de42bde45193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791f338f65f1be9a4a587774fe9b1ed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga791f338f65f1be9a4a587774fe9b1ed1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga791f338f65f1be9a4a587774fe9b1ed1">AVDTP_EVT_ABORT_STREAM_REQUESTED</a>&#160;&#160;&#160;55</td></tr>
<tr class="memdesc:ga791f338f65f1be9a4a587774fe9b1ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "abort stream" request. <br /></td></tr>
<tr class="separator:ga791f338f65f1be9a4a587774fe9b1ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056aed39ca4a8766cde542ffb6b4a531"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga056aed39ca4a8766cde542ffb6b4a531"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga056aed39ca4a8766cde542ffb6b4a531">AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED</a>&#160;&#160;&#160;56</td></tr>
<tr class="memdesc:ga056aed39ca4a8766cde542ffb6b4a531"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "change stream configuration" request. <br /></td></tr>
<tr class="separator:ga056aed39ca4a8766cde542ffb6b4a531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4a6c492fc1c378cfc88b50c74c5d93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae4a6c492fc1c378cfc88b50c74c5d93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaae4a6c492fc1c378cfc88b50c74c5d93">AVDTP_EVT_MEDIA_PACKET_RECEIVED</a>&#160;&#160;&#160;57</td></tr>
<tr class="memdesc:gaae4a6c492fc1c378cfc88b50c74c5d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a media packet. <br /></td></tr>
<tr class="separator:gaae4a6c492fc1c378cfc88b50c74c5d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c1534b561220d8bab57826d58124a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga47c1534b561220d8bab57826d58124a6">AVDTP_EVT_STREAM_CONFIGURED</a>&#160;&#160;&#160;58</td></tr>
<tr class="memdesc:ga47c1534b561220d8bab57826d58124a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully configured a stream.  <a href="#ga47c1534b561220d8bab57826d58124a6">More...</a><br /></td></tr>
<tr class="separator:ga47c1534b561220d8bab57826d58124a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c09597f17888f6b329e537d2daff714"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7c09597f17888f6b329e537d2daff714">AVDTP_EVT_STREAM_RECONFIGURED</a>&#160;&#160;&#160;59</td></tr>
<tr class="memdesc:ga7c09597f17888f6b329e537d2daff714"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully reconfigured a stream.  <a href="#ga7c09597f17888f6b329e537d2daff714">More...</a><br /></td></tr>
<tr class="separator:ga7c09597f17888f6b329e537d2daff714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b587f362b71e3ee6a3c697d1d810dfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5b587f362b71e3ee6a3c697d1d810dfb">AVDTP_EVT_STREAM_OPENED</a>&#160;&#160;&#160;60</td></tr>
<tr class="memdesc:ga5b587f362b71e3ee6a3c697d1d810dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully opened a stream.  <a href="#ga5b587f362b71e3ee6a3c697d1d810dfb">More...</a><br /></td></tr>
<tr class="separator:ga5b587f362b71e3ee6a3c697d1d810dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a1880fcf2843851bfdcc1c1ce26fe4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga30a1880fcf2843851bfdcc1c1ce26fe4">AVDTP_EVT_STREAM_STARTED</a>&#160;&#160;&#160;61</td></tr>
<tr class="memdesc:ga30a1880fcf2843851bfdcc1c1ce26fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully started a stream.  <a href="#ga30a1880fcf2843851bfdcc1c1ce26fe4">More...</a><br /></td></tr>
<tr class="separator:ga30a1880fcf2843851bfdcc1c1ce26fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf4589b4e06f8da64956618b13c6d90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaaaf4589b4e06f8da64956618b13c6d90">AVDTP_EVT_STREAM_CLOSED</a>&#160;&#160;&#160;62</td></tr>
<tr class="memdesc:gaaaf4589b4e06f8da64956618b13c6d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully closed a stream.  <a href="#gaaaf4589b4e06f8da64956618b13c6d90">More...</a><br /></td></tr>
<tr class="separator:gaaaf4589b4e06f8da64956618b13c6d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efd33cc271c43335507a3c6875461b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5efd33cc271c43335507a3c6875461b4">AVDTP_EVT_STREAM_SUSPENDED</a>&#160;&#160;&#160;63</td></tr>
<tr class="memdesc:ga5efd33cc271c43335507a3c6875461b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully suspended a stream.  <a href="#ga5efd33cc271c43335507a3c6875461b4">More...</a><br /></td></tr>
<tr class="separator:ga5efd33cc271c43335507a3c6875461b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac111c73e90b207bae2346c072960bcef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac111c73e90b207bae2346c072960bcef">AVDTP_EVT_STREAM_ABORTED</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:gac111c73e90b207bae2346c072960bcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully aborted a stream.  <a href="#gac111c73e90b207bae2346c072960bcef">More...</a><br /></td></tr>
<tr class="separator:gac111c73e90b207bae2346c072960bcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7073934f0aeaa7da349108c214ac9748"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7073934f0aeaa7da349108c214ac9748"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7073934f0aeaa7da349108c214ac9748">AVDTP_EVT_MEDIA_PACKET_SENT</a>&#160;&#160;&#160;65</td></tr>
<tr class="memdesc:ga7073934f0aeaa7da349108c214ac9748"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device sent a media packet. <br /></td></tr>
<tr class="separator:ga7073934f0aeaa7da349108c214ac9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d6753d097d685b19b733d93062b7cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2d6753d097d685b19b733d93062b7cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac2d6753d097d685b19b733d93062b7cc">AVDTP_EVT_MEDIA_PACKET_SEND_FAILED</a>&#160;&#160;&#160;66</td></tr>
<tr class="memdesc:gac2d6753d097d685b19b733d93062b7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device failed to send a media packet. <br /></td></tr>
<tr class="separator:gac2d6753d097d685b19b733d93062b7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stream States</h2></td></tr>
<tr class="memitem:ga5083c2d26bfa339841aae07a45d29e7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5083c2d26bfa339841aae07a45d29e7c">AVDTP_STREAM_STATE_IDLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga5083c2d26bfa339841aae07a45d29e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is idle.  <a href="#ga5083c2d26bfa339841aae07a45d29e7c">More...</a><br /></td></tr>
<tr class="separator:ga5083c2d26bfa339841aae07a45d29e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93716a6828c10fc125b178e243dbdbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab93716a6828c10fc125b178e243dbdbf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab93716a6828c10fc125b178e243dbdbf">AVDTP_STREAM_OPENING_TRANSPORT_CHANNELS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gab93716a6828c10fc125b178e243dbdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is opening transport channels. <br /></td></tr>
<tr class="separator:gab93716a6828c10fc125b178e243dbdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc45a8ba2ea26057524320a0253b5319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc45a8ba2ea26057524320a0253b5319"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gabc45a8ba2ea26057524320a0253b5319">AVDTP_STREAM_CLOSING_TRANSPORT_CHANNELS</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gabc45a8ba2ea26057524320a0253b5319"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is closing transport channels. <br /></td></tr>
<tr class="separator:gabc45a8ba2ea26057524320a0253b5319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa6d555344d644abe4acb4556a99b45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabaa6d555344d644abe4acb4556a99b45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gabaa6d555344d644abe4acb4556a99b45">AVDTP_STREAM_STATE_CONFIGURED</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gabaa6d555344d644abe4acb4556a99b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream has been configured. <br /></td></tr>
<tr class="separator:gabaa6d555344d644abe4acb4556a99b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f436cb3251ee66f88c411c4b99fbec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07f436cb3251ee66f88c411c4b99fbec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga07f436cb3251ee66f88c411c4b99fbec">AVDTP_STREAM_STATE_OPEN</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga07f436cb3251ee66f88c411c4b99fbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream has been opened. <br /></td></tr>
<tr class="separator:ga07f436cb3251ee66f88c411c4b99fbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c10c0b4946532635eaf471d4984d86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga97c10c0b4946532635eaf471d4984d86">AVDTP_STREAM_STATE_STREAMING</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ga97c10c0b4946532635eaf471d4984d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream has been started.  <a href="#ga97c10c0b4946532635eaf471d4984d86">More...</a><br /></td></tr>
<tr class="separator:ga97c10c0b4946532635eaf471d4984d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a143bed652a3f574dbf1041138cfd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga76a143bed652a3f574dbf1041138cfd8">AVDTP_STREAM_STATE_CLOSING</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ga76a143bed652a3f574dbf1041138cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is closing.  <a href="#ga76a143bed652a3f574dbf1041138cfd8">More...</a><br /></td></tr>
<tr class="separator:ga76a143bed652a3f574dbf1041138cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd00cfbd38a71b8d64efe494e816b3e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gadd00cfbd38a71b8d64efe494e816b3e7">AVDTP_STREAM_STATE_ABORTING</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:gadd00cfbd38a71b8d64efe494e816b3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is aborting.  <a href="#gadd00cfbd38a71b8d64efe494e816b3e7">More...</a><br /></td></tr>
<tr class="separator:gadd00cfbd38a71b8d64efe494e816b3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SEP Type</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbcac65769ac618461822e2b7060e3a6c"></a>The following is a list of SEP types. </p>
</td></tr>
<tr class="memitem:gaad17a1d784c3581a823fbd5bcbe617f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad17a1d784c3581a823fbd5bcbe617f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaad17a1d784c3581a823fbd5bcbe617f8">AVDTP_SEP_TYPE_SOURCE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaad17a1d784c3581a823fbd5bcbe617f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source (usually a device like a phone, desktop or laptop). <br /></td></tr>
<tr class="separator:gaad17a1d784c3581a823fbd5bcbe617f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f99e5a9c4f03230a3d1648231edf3ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f99e5a9c4f03230a3d1648231edf3ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5f99e5a9c4f03230a3d1648231edf3ed">AVDTP_SEP_TYPE_SINK</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5f99e5a9c4f03230a3d1648231edf3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink (usually a device like a headphones or BMW). <br /></td></tr>
<tr class="separator:ga5f99e5a9c4f03230a3d1648231edf3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Service Categories</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb398ccefc36da21cad99d237d4c9b99e"></a>The following is a list of service categories a SEP supports.</p>
<dl class="section note"><dt>Note</dt><dd>dotstack supports only AVDTP_SEP_SERVICE_CAPABILITY_MEDIA_TRANSPORT and AVDTP_SEP_SERVICE_CAPABILITY_MEDIA_CODEC. </dd>
<dd>
These constants define values that are transfered OTA. They are not use in API. Constants for initializing <a class="el" href="structbt__avdtp__sep__capabilities__t.html" title="SEP capabilities. ">bt_avdtp_sep_capabilities_t</a> structure that is used to define a SEP's capabilities are defined with AVDTP_SEP_CAPABILITY_FLAG_... constants. </dd></dl>
</td></tr>
<tr class="memitem:ga5a7315bad3e13dd0898be4086c32521a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a7315bad3e13dd0898be4086c32521a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5a7315bad3e13dd0898be4086c32521a">AVDTP_SEP_SERVICE_CAPABILITY_MEDIA_TRANSPORT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5a7315bad3e13dd0898be4086c32521a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media. A SEP is capable of transferring media (audio, video or both) packets. <br /></td></tr>
<tr class="separator:ga5a7315bad3e13dd0898be4086c32521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf000a9150e1748179f65c10ec61aad58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf000a9150e1748179f65c10ec61aad58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf000a9150e1748179f65c10ec61aad58">AVDTP_SEP_SERVICE_CAPABILITY_REPORTING</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gaf000a9150e1748179f65c10ec61aad58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reporting. A SEP is capable of transferring reporting packets. <br /></td></tr>
<tr class="separator:gaf000a9150e1748179f65c10ec61aad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e791ba988f14155b8b5cfbdf2a8806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24e791ba988f14155b8b5cfbdf2a8806"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga24e791ba988f14155b8b5cfbdf2a8806">AVDTP_SEP_SERVICE_CAPABILITY_RECOVERY</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga24e791ba988f14155b8b5cfbdf2a8806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery. A SEP is capable of transferring recovery packets. <br /></td></tr>
<tr class="separator:ga24e791ba988f14155b8b5cfbdf2a8806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dabe28133258b8e95d48def6d0efb0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5dabe28133258b8e95d48def6d0efb0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga5dabe28133258b8e95d48def6d0efb0a">AVDTP_SEP_SERVICE_CAPABILITY_CONTENT_PROTECTION</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga5dabe28133258b8e95d48def6d0efb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Content Prortection. A SEP is capable of transferring content protection packets. <br /></td></tr>
<tr class="separator:ga5dabe28133258b8e95d48def6d0efb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b32e3d36f069a81c55d1c0adced802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga77b32e3d36f069a81c55d1c0adced802"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga77b32e3d36f069a81c55d1c0adced802">AVDTP_SEP_SERVICE_CAPABILITY_HEADER_COMPRESSION</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ga77b32e3d36f069a81c55d1c0adced802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header Compression. A SEP can use header compression for transferring Media or Recovery packets. <br /></td></tr>
<tr class="separator:ga77b32e3d36f069a81c55d1c0adced802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3a78a0012003baf7ba3ff01def8864"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc3a78a0012003baf7ba3ff01def8864"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gabc3a78a0012003baf7ba3ff01def8864">AVDTP_SEP_SERVICE_CAPABILITY_MULTIPLEXING</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:gabc3a78a0012003baf7ba3ff01def8864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplexing. Multiple transport sessions, belonging to the same or to a different stream, can share a common transport (L2CAP) channel. <br /></td></tr>
<tr class="separator:gabc3a78a0012003baf7ba3ff01def8864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd658df87b2219ab686253c1f8fffd24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd658df87b2219ab686253c1f8fffd24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gabd658df87b2219ab686253c1f8fffd24">AVDTP_SEP_SERVICE_CAPABILITY_MEDIA_CODEC</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:gabd658df87b2219ab686253c1f8fffd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media Codec. Defines which codec a SEP supports. A SEP can support only one codec. <br /></td></tr>
<tr class="separator:gabd658df87b2219ab686253c1f8fffd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd2d4adbb192a07b1e010b66fa7a136"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bd2d4adbb192a07b1e010b66fa7a136"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga8bd2d4adbb192a07b1e010b66fa7a136">AVDTP_SEP_SERVICE_CAPABILITY_DELAY_REPORTING</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga8bd2d4adbb192a07b1e010b66fa7a136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Reporting. <br /></td></tr>
<tr class="separator:ga8bd2d4adbb192a07b1e010b66fa7a136"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Service Categories Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp058b05411fc01f595fa2ec9387c3b923"></a>The following is a list of constants that can be used to initialize <a class="el" href="structbt__avdtp__sep__capabilities__t.html#afbf6c3e2542b80210bcc61e51678ea77" title="Defines service capabilities exposed by a SEP to a remote party. ">bt_avdtp_sep_capabilities_t::categories</a>. A combination of these constants defines service capabilities exposed by a SEP to a remote party.</p>
<dl class="section note"><dt>Note</dt><dd>dotstack supports only AVDTP_SEP_CAPABILITY_FLAG_MEDIA_TRANSPORT and AVDTP_SEP_CAPABILITY_FLAG_MEDIA_CODEC. All other service capabilities are ignored. They are defined here only for completeness. </dd></dl>
</td></tr>
<tr class="memitem:ga94dff3ccffcadab0b531f5d8d4731ae9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94dff3ccffcadab0b531f5d8d4731ae9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga94dff3ccffcadab0b531f5d8d4731ae9">AVDTP_SEP_CAPABILITY_FLAG_MEDIA_TRANSPORT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga94dff3ccffcadab0b531f5d8d4731ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media. A SEP is capable of transferring media (audio, video or both) packets. <br /></td></tr>
<tr class="separator:ga94dff3ccffcadab0b531f5d8d4731ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62adf732bc04a154c5206f7c5b3f4570"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62adf732bc04a154c5206f7c5b3f4570"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga62adf732bc04a154c5206f7c5b3f4570">AVDTP_SEP_CAPABILITY_FLAG_REPORTING</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ga62adf732bc04a154c5206f7c5b3f4570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reporting. A SEP is capable of transferring reporting packets. <br /></td></tr>
<tr class="separator:ga62adf732bc04a154c5206f7c5b3f4570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38fb347043d1d4edee75687503b11bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab38fb347043d1d4edee75687503b11bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab38fb347043d1d4edee75687503b11bc">AVDTP_SEP_CAPABILITY_FLAG_RECOVERY</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:gab38fb347043d1d4edee75687503b11bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery. A SEP is capable of transferring recovery packets. <br /></td></tr>
<tr class="separator:gab38fb347043d1d4edee75687503b11bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e0451302499350e1eb46333e99c26a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97e0451302499350e1eb46333e99c26a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga97e0451302499350e1eb46333e99c26a">AVDTP_SEP_CAPABILITY_FLAG_CONTENT_PROTECTION</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ga97e0451302499350e1eb46333e99c26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Content Prortection. A SEP is capable of transferring content protection packets. <br /></td></tr>
<tr class="separator:ga97e0451302499350e1eb46333e99c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cff69aee8167b2ab1312f619dfb87c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3cff69aee8167b2ab1312f619dfb87c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3cff69aee8167b2ab1312f619dfb87c0">AVDTP_SEP_CAPABILITY_FLAG_HEADER_COMPRESSION</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:ga3cff69aee8167b2ab1312f619dfb87c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header Compression. A SEP can use header compression for transferring Media or Recovery packets. <br /></td></tr>
<tr class="separator:ga3cff69aee8167b2ab1312f619dfb87c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433c8189d766c6bc887b31e1ba183bb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga433c8189d766c6bc887b31e1ba183bb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga433c8189d766c6bc887b31e1ba183bb0">AVDTP_SEP_CAPABILITY_FLAG_MULTIPLEXING</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga433c8189d766c6bc887b31e1ba183bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplexing. Multiple transport sessions, belonging to the same or to a different stream, can share a common transport (L2CAP) channel. <br /></td></tr>
<tr class="separator:ga433c8189d766c6bc887b31e1ba183bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadd17fb0df868f23818e8f11afae8de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadadd17fb0df868f23818e8f11afae8de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gadadd17fb0df868f23818e8f11afae8de">AVDTP_SEP_CAPABILITY_FLAG_MEDIA_CODEC</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:gadadd17fb0df868f23818e8f11afae8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media Codec. Defines which codec a SEP supports. A SEP can support only one codec. <br /></td></tr>
<tr class="separator:gadadd17fb0df868f23818e8f11afae8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76d8714100f13db3499f6e175b807da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad76d8714100f13db3499f6e175b807da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad76d8714100f13db3499f6e175b807da">AVDTP_SEP_CAPABILITY_FLAG_DELAY_REPORTING</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:gad76d8714100f13db3499f6e175b807da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delat reporitng. <br /></td></tr>
<tr class="separator:gad76d8714100f13db3499f6e175b807da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Transport Session Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa63a3cd32b08c2896639139897786b93"></a>The following is a list of transport sessions a SEP supports.</p>
<dl class="section note"><dt>Note</dt><dd>The only transport session cyrrently supported by dotstack is AVDTP_TRANSPORT_SESSION_TYPE_MEDIA. </dd></dl>
</td></tr>
<tr class="memitem:ga48bc96fb64b2ffef92bbbdf302dc3c19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga48bc96fb64b2ffef92bbbdf302dc3c19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga48bc96fb64b2ffef92bbbdf302dc3c19">AVDTP_TRANSPORT_SESSION_TYPE_MEDIA</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga48bc96fb64b2ffef92bbbdf302dc3c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media (audio or video). <br /></td></tr>
<tr class="separator:ga48bc96fb64b2ffef92bbbdf302dc3c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b204f86fdaa07ed50daff76920a3bf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b204f86fdaa07ed50daff76920a3bf4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga9b204f86fdaa07ed50daff76920a3bf4">AVDTP_TRANSPORT_SESSION_TYPE_REPORTING</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga9b204f86fdaa07ed50daff76920a3bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reporting (currently not supported). <br /></td></tr>
<tr class="separator:ga9b204f86fdaa07ed50daff76920a3bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1dd6e5f629c951e5cbe398bc6255ea0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1dd6e5f629c951e5cbe398bc6255ea0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gac1dd6e5f629c951e5cbe398bc6255ea0">AVDTP_TRANSPORT_SESSION_TYPE_RECOVERY</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gac1dd6e5f629c951e5cbe398bc6255ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery (currently not supported). <br /></td></tr>
<tr class="separator:gac1dd6e5f629c951e5cbe398bc6255ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Codec Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb59406fe9e39afc37624f9b8efa9b10d"></a>The following is a list of codecs a SEP supports. </p>
</td></tr>
<tr class="memitem:gad559c354d5ae8931ecc82b6e2468d19a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad559c354d5ae8931ecc82b6e2468d19a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad559c354d5ae8931ecc82b6e2468d19a">AVDTP_CODEC_TYPE_SBC</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:gad559c354d5ae8931ecc82b6e2468d19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBC (mandatory to support in A2DP profile). <br /></td></tr>
<tr class="separator:gad559c354d5ae8931ecc82b6e2468d19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f527974b8744ff58e4b99a6f407852e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f527974b8744ff58e4b99a6f407852e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7f527974b8744ff58e4b99a6f407852e">AVDTP_CODEC_TYPE_MPEG1_2_AUDIO</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga7f527974b8744ff58e4b99a6f407852e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPEG-1,2 (optional). <br /></td></tr>
<tr class="separator:ga7f527974b8744ff58e4b99a6f407852e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69126dd24004ce044b8d24a375de7fde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69126dd24004ce044b8d24a375de7fde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga69126dd24004ce044b8d24a375de7fde">AVDTP_CODEC_TYPE_MPEG2_4_AAC</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ga69126dd24004ce044b8d24a375de7fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPEG-2,4 AAC (optional, used in Apple's products). <br /></td></tr>
<tr class="separator:ga69126dd24004ce044b8d24a375de7fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87994800b541d40736eb34839ecd3c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87994800b541d40736eb34839ecd3c39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga87994800b541d40736eb34839ecd3c39">AVDTP_CODEC_TYPE_ATRAC</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:ga87994800b541d40736eb34839ecd3c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATRAC (proprietary codec owned by Sony Corporation). <br /></td></tr>
<tr class="separator:ga87994800b541d40736eb34839ecd3c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b387f58d23d3f60b81cf08a6289cd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf7b387f58d23d3f60b81cf08a6289cd3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf7b387f58d23d3f60b81cf08a6289cd3">AVDTP_CODEC_TYPE_NON_A2DP</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:gaf7b387f58d23d3f60b81cf08a6289cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor specific. <br /></td></tr>
<tr class="separator:gaf7b387f58d23d3f60b81cf08a6289cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Media Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp34c86f21205afa47d89ae4b045624b31"></a>The following is a list of media types a SEP can support. </p>
</td></tr>
<tr class="memitem:gab36b796b580adc8c67eabdfae8d035a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab36b796b580adc8c67eabdfae8d035a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab36b796b580adc8c67eabdfae8d035a3">AVDTP_MEDIA_TYPE_AUDIO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gab36b796b580adc8c67eabdfae8d035a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio. <br /></td></tr>
<tr class="separator:gab36b796b580adc8c67eabdfae8d035a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3c2b67d2397f0209aa07c1b0c7c536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b3c2b67d2397f0209aa07c1b0c7c536"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga0b3c2b67d2397f0209aa07c1b0c7c536">AVDTP_MEDIA_TYPE_VIDEO</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga0b3c2b67d2397f0209aa07c1b0c7c536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video. <br /></td></tr>
<tr class="separator:ga0b3c2b67d2397f0209aa07c1b0c7c536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f831257dc8f3743f147ec660c4aeeb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f831257dc8f3743f147ec660c4aeeb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3f831257dc8f3743f147ec660c4aeeb0">AVDTP_MEDIA_TYPE_MULTIMEDIA</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga3f831257dc8f3743f147ec660c4aeeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Both Audio &amp; Video. <br /></td></tr>
<tr class="separator:ga3f831257dc8f3743f147ec660c4aeeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Codec Handler Operations</h2></td></tr>
<tr class="memitem:ga7a015633e6aee93c62a0d366b048fc10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a015633e6aee93c62a0d366b048fc10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7a015633e6aee93c62a0d366b048fc10">AVDTP_CODEC_OPCODE_PARSE_CONFIG</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga7a015633e6aee93c62a0d366b048fc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse codec configuration. <br /></td></tr>
<tr class="separator:ga7a015633e6aee93c62a0d366b048fc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036f8b6a002403abb1e417fc0fe9c4f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga036f8b6a002403abb1e417fc0fe9c4f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga036f8b6a002403abb1e417fc0fe9c4f2">AVDTP_CODEC_OPCODE_SERIALIZE_CONFIG</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga036f8b6a002403abb1e417fc0fe9c4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize codec configuration. <br /></td></tr>
<tr class="separator:ga036f8b6a002403abb1e417fc0fe9c4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Error Codes</h2></td></tr>
<tr class="memitem:ga7c9dc3498d12bc99b686ac7c574d07ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c9dc3498d12bc99b686ac7c574d07ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga7c9dc3498d12bc99b686ac7c574d07ca">AVDTP_ERROR_SUCCESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga7c9dc3498d12bc99b686ac7c574d07ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation completed with no errors. <br /></td></tr>
<tr class="separator:ga7c9dc3498d12bc99b686ac7c574d07ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0044e22ccbf21085336ada188d6d8f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0044e22ccbf21085336ada188d6d8f59"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga0044e22ccbf21085336ada188d6d8f59">AVDTP_ERROR_BAD_HEADER_FORMAT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga0044e22ccbf21085336ada188d6d8f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">The request packet header format is invalid. <br /></td></tr>
<tr class="separator:ga0044e22ccbf21085336ada188d6d8f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace09ab153a84a2e78b31d188e1e42bc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace09ab153a84a2e78b31d188e1e42bc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gace09ab153a84a2e78b31d188e1e42bc7">AVDTP_ERROR_BAD_LENGTH</a>&#160;&#160;&#160;0x11</td></tr>
<tr class="memdesc:gace09ab153a84a2e78b31d188e1e42bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The request packet length is not match the assumed length. <br /></td></tr>
<tr class="separator:gace09ab153a84a2e78b31d188e1e42bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3958b81990b3099490715584aa42db3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3958b81990b3099490715584aa42db3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga3958b81990b3099490715584aa42db3b">AVDTP_ERROR_BAD_ACP_SEID</a>&#160;&#160;&#160;0x12</td></tr>
<tr class="memdesc:ga3958b81990b3099490715584aa42db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested command indicates an invalid ACP SEP ID (not addressable) <br /></td></tr>
<tr class="separator:ga3958b81990b3099490715584aa42db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71b8c300d3190d7563079cf623025a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf71b8c300d3190d7563079cf623025a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf71b8c300d3190d7563079cf623025a5">AVDTP_ERROR_SEP_IN_USE</a>&#160;&#160;&#160;0x13</td></tr>
<tr class="memdesc:gaf71b8c300d3190d7563079cf623025a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SEP is in use. <br /></td></tr>
<tr class="separator:gaf71b8c300d3190d7563079cf623025a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7ed3d0eb707b269c52e3737226ae64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace7ed3d0eb707b269c52e3737226ae64"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gace7ed3d0eb707b269c52e3737226ae64">AVDTP_ERROR_SEP_NOT_IN_USE</a>&#160;&#160;&#160;0x14</td></tr>
<tr class="memdesc:gace7ed3d0eb707b269c52e3737226ae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SEP is not in use. <br /></td></tr>
<tr class="separator:gace7ed3d0eb707b269c52e3737226ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b69214074c9b4e05fb1f21171770a66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b69214074c9b4e05fb1f21171770a66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga1b69214074c9b4e05fb1f21171770a66">AVDTP_ERROR_BAD_SERV_CATEGORY</a>&#160;&#160;&#160;0x17</td></tr>
<tr class="memdesc:ga1b69214074c9b4e05fb1f21171770a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of Service Category in the request packet is not defined in AVDTP. <br /></td></tr>
<tr class="separator:ga1b69214074c9b4e05fb1f21171770a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9865f8543ba13e2865529f471509184"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9865f8543ba13e2865529f471509184"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gab9865f8543ba13e2865529f471509184">AVDTP_ERROR_BAD_PAYLOAD_FORMAT</a>&#160;&#160;&#160;0x18</td></tr>
<tr class="memdesc:gab9865f8543ba13e2865529f471509184"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested command has an incorrect payload format. <br /></td></tr>
<tr class="separator:gab9865f8543ba13e2865529f471509184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6a8dd431350611eb6a8a7c05a2bd70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2b6a8dd431350611eb6a8a7c05a2bd70"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga2b6a8dd431350611eb6a8a7c05a2bd70">AVDTP_ERROR_NOT_SUPPORTED_COMMAND</a>&#160;&#160;&#160;0x19</td></tr>
<tr class="memdesc:ga2b6a8dd431350611eb6a8a7c05a2bd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested command is not supported by the device. <br /></td></tr>
<tr class="separator:ga2b6a8dd431350611eb6a8a7c05a2bd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9e63b8376d357a75aa83ff887e07f2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9e63b8376d357a75aa83ff887e07f2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gad9e63b8376d357a75aa83ff887e07f2b">AVDTP_ERROR_INVALID_CAPABILITIES</a>&#160;&#160;&#160;0x1a</td></tr>
<tr class="memdesc:gad9e63b8376d357a75aa83ff887e07f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reconfigure command is an attempt to reconfigure a transport service capabilities of the SEP. Reconfigure is only permitted for application service capabilities. <br /></td></tr>
<tr class="separator:gad9e63b8376d357a75aa83ff887e07f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4129223e457313e39f122d804a78af32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4129223e457313e39f122d804a78af32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga4129223e457313e39f122d804a78af32">AVDTP_ERROR_BAD_RECOVERY_TYPE</a>&#160;&#160;&#160;0x22</td></tr>
<tr class="memdesc:ga4129223e457313e39f122d804a78af32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested Recovery Type is not defined in AVDTP. <br /></td></tr>
<tr class="separator:ga4129223e457313e39f122d804a78af32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a9b75c89340e36b28d58df3d8e8f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga52a9b75c89340e36b28d58df3d8e8f82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga52a9b75c89340e36b28d58df3d8e8f82">AVDTP_ERROR_BAD_MEDIA_TRANSPORT_FORMAT</a>&#160;&#160;&#160;0x23</td></tr>
<tr class="memdesc:ga52a9b75c89340e36b28d58df3d8e8f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of Media Transport Capability is not correct. <br /></td></tr>
<tr class="separator:ga52a9b75c89340e36b28d58df3d8e8f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407c0de365ddcb4f8d14a6a0909b8da0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga407c0de365ddcb4f8d14a6a0909b8da0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga407c0de365ddcb4f8d14a6a0909b8da0">AVDTP_ERROR_BAD_RECOVERY_FORMAT</a>&#160;&#160;&#160;0x25</td></tr>
<tr class="memdesc:ga407c0de365ddcb4f8d14a6a0909b8da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of Recovery Service Capability is not correct. <br /></td></tr>
<tr class="separator:ga407c0de365ddcb4f8d14a6a0909b8da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8795386bcba3652d98155f2594ee5bc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8795386bcba3652d98155f2594ee5bc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga8795386bcba3652d98155f2594ee5bc4">AVDTP_ERROR_BAD_ROHC_FORMAT</a>&#160;&#160;&#160;0x26</td></tr>
<tr class="memdesc:ga8795386bcba3652d98155f2594ee5bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of Header Compression Service Capability is not correct. <br /></td></tr>
<tr class="separator:ga8795386bcba3652d98155f2594ee5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9671d312c4cc9edebe99d3dc5a4bc8aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9671d312c4cc9edebe99d3dc5a4bc8aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga9671d312c4cc9edebe99d3dc5a4bc8aa">AVDTP_ERROR_BAD_CP_FORMAT</a>&#160;&#160;&#160;0x27</td></tr>
<tr class="memdesc:ga9671d312c4cc9edebe99d3dc5a4bc8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of Content Protection Service Capability is not correct. <br /></td></tr>
<tr class="separator:ga9671d312c4cc9edebe99d3dc5a4bc8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee74416e8b170cca1e64c1b29751c3a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee74416e8b170cca1e64c1b29751c3a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaee74416e8b170cca1e64c1b29751c3a8">AVDTP_ERROR_BAD_MULTIPLEXING_FORMAT</a>&#160;&#160;&#160;0x28</td></tr>
<tr class="memdesc:gaee74416e8b170cca1e64c1b29751c3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of Multiplexing Service Capability is not correct. <br /></td></tr>
<tr class="separator:gaee74416e8b170cca1e64c1b29751c3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218c1ed1bcaa0972624fcc4b18fdfef0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga218c1ed1bcaa0972624fcc4b18fdfef0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#ga218c1ed1bcaa0972624fcc4b18fdfef0">AVDTP_ERROR_UNSUPPORTED_CONFIGURAION</a>&#160;&#160;&#160;0x29</td></tr>
<tr class="memdesc:ga218c1ed1bcaa0972624fcc4b18fdfef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration not supported. <br /></td></tr>
<tr class="separator:ga218c1ed1bcaa0972624fcc4b18fdfef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47c001d7a247dac2d820aa750518d54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf47c001d7a247dac2d820aa750518d54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf47c001d7a247dac2d820aa750518d54">AVDTP_ERROR_BAD_STATE</a>&#160;&#160;&#160;0x31</td></tr>
<tr class="memdesc:gaf47c001d7a247dac2d820aa750518d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is in state that does not permit executing commands. <br /></td></tr>
<tr class="separator:gaf47c001d7a247dac2d820aa750518d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ebe93b77f1fbfe53687aa968e1fa45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0ebe93b77f1fbfe53687aa968e1fa45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gae0ebe93b77f1fbfe53687aa968e1fa45">AVDTP_ERROR_FAILED_TO_CONNECT_TRANSPORT</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:gae0ebe93b77f1fbfe53687aa968e1fa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attempt to esctablish a transport channel has failed. <br /></td></tr>
<tr class="separator:gae0ebe93b77f1fbfe53687aa968e1fa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8db6a0bf328ae06fa303a4363f76b45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8db6a0bf328ae06fa303a4363f76b45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdtp.html#gaf8db6a0bf328ae06fa303a4363f76b45">AVDTP_ERROR_FAILED_TO_CONNECT_CONTROL</a>&#160;&#160;&#160;0x41</td></tr>
<tr class="memdesc:gaf8db6a0bf328ae06fa303a4363f76b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attempt to esctablish a control channel has failed. <br /></td></tr>
<tr class="separator:gaf8db6a0bf328ae06fa303a4363f76b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>AVDTP is the transport protocol for audio and/or video distribution connections and streaming of audio or video media over the Bluetooth air interface. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac111c73e90b207bae2346c072960bcef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_ABORTED&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully aborted a stream. </p>
<p>This event follows the AVDTP_EVT_ABORT_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream abortion was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gaaaf4589b4e06f8da64956618b13c6d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_CLOSED&#160;&#160;&#160;62</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully closed a stream. </p>
<p>This event follows the AVDTP_EVT_CLOSE_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream closing was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga47c1534b561220d8bab57826d58124a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_CONFIGURED&#160;&#160;&#160;58</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully configured a stream. </p>
<p>This event follows the AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED if the upper layer has accepted it. This event is not generated if stream configuration was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga5b587f362b71e3ee6a3c697d1d810dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_OPENED&#160;&#160;&#160;60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully opened a stream. </p>
<p>This event follows the AVDTP_EVT_OPEN_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream opening was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga7c09597f17888f6b329e537d2daff714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_RECONFIGURED&#160;&#160;&#160;59</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully reconfigured a stream. </p>
<p>This event follows the AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream reconfiguration was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga30a1880fcf2843851bfdcc1c1ce26fe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_STARTED&#160;&#160;&#160;61</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully started a stream. </p>
<p>This event follows the AVDTP_EVT_START_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream starting was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga5efd33cc271c43335507a3c6875461b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_EVT_STREAM_SUSPENDED&#160;&#160;&#160;63</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully suspended a stream. </p>
<p>This event follows the AVDTP_EVT_SUSPEND_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream suspension was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gadd00cfbd38a71b8d64efe494e816b3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_STREAM_STATE_ABORTING&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream is aborting. </p>
<p>This means that all transport channels associated with the stream are being closed. After they have been closed the stream goes to AVDTP_STREAM_STATE_IDLE state. </p>

</div>
</div>
<a class="anchor" id="ga76a143bed652a3f574dbf1041138cfd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_STREAM_STATE_CLOSING&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream is closing. </p>
<p>This means that all transport channels associated with the stream are being closed. After they have been closed the stream goes to AVDTP_STREAM_STATE_IDLE state. </p>

</div>
</div>
<a class="anchor" id="ga5083c2d26bfa339841aae07a45d29e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_STREAM_STATE_IDLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream is idle. </p>
<p>This can mean two things. The stream specified by strm_handle does not exist or the stream is closed. </p>

</div>
</div>
<a class="anchor" id="ga97c10c0b4946532635eaf471d4984d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVDTP_STREAM_STATE_STREAMING&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream has been started. </p>
<p>Depending on the local SEP type (source or sink) it means that the stream can send or receive media packets. </p>

</div>
</div>
<a class="anchor" id="gadc565b71c9d76e8a3c6c838436605b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_avdtp_connect</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_bt_avdtp_open_control_channel_ex(mgr, remote_addr, HCI_CONFIG_ENABLE_AUTHENTICATION | HCI_CONFIG_ENABLE_ENCRYPTION)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote device. </p>
<p>This function opens a control channel connection to a remote device specified by the <code>remote_addr</code>. If connection cannot be initiated for some reason, for example, there is not enough resources, it returns FALSE and not events are generated. Otherwise the result of an attempt to connect to the remote device is reported via the AVDTP callback. The events generated will either be AVDTP_EVT_CTRL_CHANNEL_CONNECTED or AVDTP_EVT_CTRL_CHANNEL_CONNECTION_FAILED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if connection establishment has been started. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga258c796e3a420d6fc29d10035fe47cd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_avdtp_connect_ex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">acl_config&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_bt_avdtp_open_control_channel_ex(mgr, remote_addr, acl_config)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote device. </p>
<p>This function opens a control channel connection to a remote device specified by the <code>remote_addr</code>. If connection cannot be initiated for some reason, for example, there is not enough resources, it returns FALSE and not events are generated. Otherwise the result of an attempt to connect to the remote device is reported via the AVDTP callback. The events generated will either be AVDTP_EVT_CTRL_CHANNEL_CONNECTED or AVDTP_EVT_CTRL_CHANNEL_CONNECTION_FAILED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">acl_config</td><td>ACL link configuration. This can be a combination of the following values: <ul>
<li>HCI_CONFIG_ENABLE_AUTHENTICATION </li>
<li>HCI_CONFIG_ENABLE_ENCRYPTION </li>
<li>HCI_CONFIG_BECOME_MASTER</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if connection establishment has been started. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gace691b5255436e9b09a3d18b23e33395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bt_byte(* bt_avdtp_codec_handler_fp) (struct _bt_avdtp_codec_t *codec, bt_byte opcode, bt_avdtp_codec_op_param_t *op_param, struct _bt_avdtp_mgr_t *mgr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Codec handler. </p>
<p>AVDTP in theory can support any type of codec. Each codec uses its own format for exchanging capabilities and configuration information. In order to make out implementation do not care about these formats we use a simple way of telling AVDTP how to parse and serialize codec's configuration. The consumer of AVDTP (e.g. A2DP) for each codec it wishes to support has to register a callback function (one per codec type). That callback has to perform two function. The first one is to read the configuration received from the remote device and store it in a structure defined by the consumer. The second one is to serialize the data from a structure to a format (in case of standard A2DP codecs the format is defined in A2DP specification, vendor specific codecs can define their own formats) suitable for sending as a part of a AVDTP request.<br />
 This typedef defines the interace for the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codec</td><td>A pointer to a structure that describes a codec. </td></tr>
    <tr><td class="paramname">opcode</td><td>The code of an operation to execute. The <code>opcode</code> can be one of the following values: <ul>
<li>AVDTP_CODEC_OPCODE_PARSE_CONFIG: The handler has to parse configuration received from the remote device and store it in a structure defined by the consumer. </li>
<li>AVDTP_CODEC_OPCODE_SERIALIZE_CONFIG: The handler has to serialize the data from a consumer defined structure to a format suitable for sending as a part of a AVDTP request. </li>
</ul>
</td></tr>
    <tr><td class="paramname">op_param</td><td>A pointer to the operation's specific parameters. Parameters are passed as a pointer to the bt_avdtp_codec_op_param_t union. Which member of the union points to a valid structure depends on the value of the <code>opcode:</code> <ul>
<li>bt_avdtp_codec_op_param_t::parse: Valid if <code>opcode</code> == AVDTP_CODEC_OPCODE_PARSE_CONFIG. </li>
<li>bt_avdtp_codec_op_param_t::serialize: Valid if <code>opcode</code> == AVDTP_CODEC_OPCODE_SERIALIZE_CONFIG. </li>
</ul>
</td></tr>
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad2d105a7645343cec9c5da702afaa844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* bt_avdtp_mgr_callback_fp) (struct _bt_avdtp_mgr_t *mgr, bt_byte evt, <a class="el" href="unionbt__avdtp__event__t.html">bt_avdtp_event_t</a> *evt_param, void *callback_param)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVDTP application callback. </p>
<p>In order to be notified of various events a consumer of the AVDTP layer has to register a callback function. The stack will call that function whenever a new event has been generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager.</td></tr>
    <tr><td class="paramname">evt</td><td>AVDTP event. The event can be one of the following values: <ul>
<li>AVDTP_EVT_CTRL_CHANNEL_CONNECTED: Control channel connected. </li>
<li>AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED: Control channel disconnected. </li>
<li>AVDTP_EVT_CTRL_CONNECTION_FAILED: Control channel connection failed (generated only if control connection has been initiated by the local device). </li>
<li>AVDTP_EVT_DISCOVER_COMPLETED: Local device completed discovering remote SEPs. </li>
<li>AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED: Local device received a response to Get SEP capabilities operation. </li>
<li>AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Set stream configuration operation. </li>
<li>AVDTP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Get stream configuration operation. </li>
<li>AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED: Local device received a response to Reconfigure stream operation. </li>
<li>AVDTP_EVT_OPEN_STREAM_COMPLETED: Local device received a response to Open stream operation. </li>
<li>AVDTP_EVT_START_STREAM_COMPLETED: Local device received a response to Start stream operation. </li>
<li>AVDTP_EVT_CLOSE_STREAM_COMPLETED: Local device received a response to Close stream operation. </li>
<li>AVDTP_EVT_SUSPEND_STREAM_COMPLETED: Local device received a response to Suspend stream operation. </li>
<li>AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED: Local device received a response to Stream security control operation. </li>
<li>AVDTP_EVT_ABORT_STREAM_COMPLETED: Local device received a response to Abort stream operation. </li>
<li>AVDTP_EVT_SEP_INFO_RECEIVED: SEP information received. </li>
<li>AVDTP_EVT_SEP_CAPABILITIES_RECEIVED: SEP capabilities received. </li>
<li>AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED: Stream configuration received.</li>
</ul>
<ul>
<li>AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED: Remote device requested stream configuration. </li>
<li>AVDTP_EVT_OPEN_STREAM_REQUESTED: Remote device requested to open a stream. </li>
<li>AVDTP_EVT_START_STREAM_REQUESTED: Remote device requested to start a stream. </li>
<li>AVDTP_EVT_CLOSE_STREAM_REQUESTED: Remote device requested to close a stream. </li>
<li>AVDTP_EVT_SUSPEND_STREAM_REQUESTED: Remote device requested to suspend a stream. </li>
<li>AVDTP_EVT_ABORT_STREAM_REQUESTED: Remote device requested to abort a stream. </li>
<li>AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED: Remote device requested to reconfigure a stream. </li>
<li>AVDTP_EVT_MEDIA_PACKET_RECEIVED: Remote device sent a media packet. </li>
<li>AVDTP_EVT_STREAM_CONFIGURED: A stream has been configured (This event is generated right after AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_RECONFIGURED: A stream has been re-configured (This event is generated right after AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_OPENED: A stream has been opened (This event is generated as a result of local or remote stream opening request). </li>
<li>AVDTP_EVT_STREAM_STARTED: A stream has been started (This event is generated right after AVDTP_EVT_START_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_CLOSED: A stream has been close (This event is generated right after AVDTP_EVT_CLOSE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_SUSPENDED: A stream has been suspended (This event is generated right after AVDTP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_ABORTED: A stream has been aborted (This event is generated right after AVDTP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request. It is also generated if connection between devices has been terminated by means other than AVDTP signaling, e.g. devices going out of rage). </li>
<li>AVDTP_EVT_MEDIA_PACKET_SENT: The local device has successfully sent a media packet to the remote device. </li>
<li>AVDTP_EVT_MEDIA_PACKET_SEND_FAILED: The local device was not able to send a media packet to the remote device.</li>
</ul>
</td></tr>
    <tr><td class="paramname">evt_param</td><td>Event parameter. Which member of the <a class="el" href="unionbt__avdtp__event__t.html" title="Parameter to an application callback. ">bt_avdtp_event_t</a> union is valid depends on the event: <ul>
<li>AVDTP_EVT_CTRL_CHANNEL_CONNECTED: <code><a class="el" href="structbt__avdtp__evt__ctrl__channel__connected__t.html" title="Parameter to AVDTP_EVT_CTRL_CHANNEL_CONNECTED event. ">bt_avdtp_evt_ctrl_channel_connected_t</a></code> ctrl_channel_connected </li>
<li>AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED: <code><a class="el" href="structbt__avdtp__evt__ctrl__channel__disconnected__t.html" title="Parameter to AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED event. ">bt_avdtp_evt_ctrl_channel_disconnected_t</a></code> ctrl_channel_disconnected </li>
<li>AVDTP_EVT_CTRL_CONNECTION_FAILED: <code>NULL</code> </li>
<li>AVDTP_EVT_DISCOVER_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__discover__completed__t.html" title="Parameter to AVDTP_EVT_DISCOVER_COMPLETED event. ">bt_avdtp_evt_discover_completed_t</a></code> discover_completed; </li>
<li>AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__get__sep__capabilities__completed__t.html" title="Parameter to AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED event. ">bt_avdtp_evt_get_sep_capabilities_completed_t</a></code> get_sep_capabilities_completed </li>
<li>AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__set__stream__configuration__completed__t.html" title="Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event. ">bt_avdtp_evt_set_stream_configuration_completed_t</a></code> set_stream_configuration_completed </li>
<li>AVDTP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__get__stream__configuration__completed__t.html" title="Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event. ">bt_avdtp_evt_get_stream_configuration_completed_t</a></code> get_stream_configuration_completed </li>
<li>AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__stream__reconfigure__completed__t.html" title="Parameter to AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED event. ">bt_avdtp_evt_stream_reconfigure_completed_t</a></code> stream_reconfigure_completed </li>
<li>AVDTP_EVT_OPEN_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__open__stream__completed__t.html" title="Parameter to AVDTP_EVT_OPEN_STREAM_COMPLETED event. ">bt_avdtp_evt_open_stream_completed_t</a></code> open_stream_completed </li>
<li>AVDTP_EVT_START_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__start__stream__completed__t.html" title="Parameter to AVDTP_EVT_START_STREAM_COMPLETED event. ">bt_avdtp_evt_start_stream_completed_t</a></code> start_stream_completed </li>
<li>AVDTP_EVT_CLOSE_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__close__stream__completed__t.html" title="Parameter to AVDTP_EVT_CLOSE_STREAM_COMPLETED event. ">bt_avdtp_evt_close_stream_completed_t</a></code> close_stream_completed </li>
<li>AVDTP_EVT_SUSPEND_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__suspend__stream__completed__t.html" title="Parameter to AVDTP_EVT_SUSPEND_STREAM_COMPLETED event. ">bt_avdtp_evt_suspend_stream_completed_t</a></code> suspend_stream_completed </li>
<li>AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__stream__security__control__completed__t.html" title="Parameter to AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED event. ">bt_avdtp_evt_stream_security_control_completed_t</a></code> security_control_completed </li>
<li>AVDTP_EVT_ABORT_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__abort__stream__requested__t.html" title="Parameter to AVDTP_EVT_ABORT_STREAM_REQUESTED event. ">bt_avdtp_evt_abort_stream_requested_t</a></code> abort_stream_requested </li>
<li>AVDTP_EVT_SEP_INFO_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__sep__info__received__t.html" title="Parameter to AVDTP_EVT_SEP_INFO_RECEIVED event. ">bt_avdtp_evt_sep_info_received_t</a></code> sep_info_received </li>
<li>AVDTP_EVT_SEP_CAPABILITIES_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__sep__capabilities__received__t.html" title="Parameter to AVDTP_EVT_SEP_CAPABILITIES_RECEIVED and AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED events...">bt_avdtp_evt_sep_capabilities_received_t</a></code> sep_capabilities_received </li>
<li>AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__sep__capabilities__received__t.html" title="Parameter to AVDTP_EVT_SEP_CAPABILITIES_RECEIVED and AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED events...">bt_avdtp_evt_sep_capabilities_received_t</a></code> sep_capabilities_received</li>
</ul>
<ul>
<li>AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__set__stream__configuration__requested__t.html" title="Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED event. ">bt_avdtp_evt_set_stream_configuration_requested_t</a></code> set_stream_configuration_requested </li>
<li>AVDTP_EVT_OPEN_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__open__stream__requested__t.html" title="Parameter to AVDTP_EVT_OPEN_STREAM_REQUESTED event. ">bt_avdtp_evt_open_stream_requested_t</a></code> open_stream_requested </li>
<li>AVDTP_EVT_START_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__start__stream__requested__t.html" title="Parameter to AVDTP_EVT_START_STREAM_REQUESTED event. ">bt_avdtp_evt_start_stream_requested_t</a></code> start_stream_requested </li>
<li>AVDTP_EVT_CLOSE_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__close__stream__requested__t.html" title="Parameter to AVDTP_EVT_CLOSE_STREAM_REQUESTED event. ">bt_avdtp_evt_close_stream_requested_t</a></code> close_stream_requested </li>
<li>AVDTP_EVT_SUSPEND_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__suspend__stream__requested__t.html" title="Parameter to AVDTP_EVT_SUSPEND_STREAM_REQUESTED event. ">bt_avdtp_evt_suspend_stream_requested_t</a></code> suspend_stream_requested </li>
<li>AVDTP_EVT_ABORT_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__abort__stream__requested__t.html" title="Parameter to AVDTP_EVT_ABORT_STREAM_REQUESTED event. ">bt_avdtp_evt_abort_stream_requested_t</a></code> abort_stream_requested </li>
<li>AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__reconfigure__stream__requested__t.html" title="Parameter to AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED event. ">bt_avdtp_evt_reconfigure_stream_requested_t</a></code> reconfigure_stream_requested </li>
<li>AVDTP_EVT_MEDIA_PACKET_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__media__packet__received__t.html" title="Parameter to AVDTP_EVT_MEDIA_PACKET_RECEIVED event. ">bt_avdtp_evt_media_packet_received_t</a></code> media_packet_received </li>
<li>AVDTP_EVT_STREAM_CONFIGURED: <code><a class="el" href="structbt__avdtp__evt__stream__configured__t.html" title="Parameter to AVDTP_EVT_STREAM_CONFIGURED event. ">bt_avdtp_evt_stream_configured_t</a></code> stream_configured </li>
<li>AVDTP_EVT_STREAM_RECONFIGURED: <code><a class="el" href="structbt__avdtp__evt__stream__reconfigured__t.html" title="Parameter to AVDTP_EVT_STREAM_RECONFIGURED event. ">bt_avdtp_evt_stream_reconfigured_t</a></code> stream_reconfigured </li>
<li>AVDTP_EVT_STREAM_OPENED: <code><a class="el" href="structbt__avdtp__evt__stream__opened__t.html" title="Parameter to AVDTP_EVT_STREAM_OPENED event. ">bt_avdtp_evt_stream_opened_t</a></code> stream_opened </li>
<li>AVDTP_EVT_STREAM_STARTED: <code><a class="el" href="structbt__avdtp__evt__stream__started__t.html" title="Parameter to AVDTP_EVT_STREAM_STARTED event. ">bt_avdtp_evt_stream_started_t</a></code> stream_started </li>
<li>AVDTP_EVT_STREAM_CLOSED: <code><a class="el" href="structbt__avdtp__evt__stream__closed__t.html" title="Parameter to AVDTP_EVT_STREAM_CLOSED event. ">bt_avdtp_evt_stream_closed_t</a></code> stream_closed </li>
<li>AVDTP_EVT_STREAM_SUSPENDED: <code><a class="el" href="structbt__avdtp__evt__stream__suspended__t.html" title="Parameter to AVDTP_EVT_STREAM_SUSPENDED event. ">bt_avdtp_evt_stream_suspended_t</a></code> stream_suspended </li>
<li>AVDTP_EVT_STREAM_ABORTED: <code><a class="el" href="structbt__avdtp__evt__stream__aborted__t.html" title="Parameter to AVDTP_EVT_STREAM_ABORTED event. ">bt_avdtp_evt_stream_aborted_t</a></code> stream_aborted </li>
<li>AVDTP_EVT_MEDIA_PACKET_SENT: <code><a class="el" href="structbt__avdtp__evt__media__packet__sent__t.html" title="Parameter to AVDTP_EVT_MEDIA_PACKET_SENT event. ">bt_avdtp_evt_media_packet_sent_t</a></code> media_packet_sent </li>
<li>AVDTP_EVT_MEDIA_PACKET_SEND_FAILED: <code><a class="el" href="structbt__avdtp__evt__media__packet__send__failed__t.html" title="Parameter to AVDTP_EVT_MEDIA_PACKET_SEND_FAILED event. ">bt_avdtp_evt_media_packet_send_failed_t</a></code> media_packet_send_failed</li>
</ul>
</td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to an arbitrary data set by a call to bt_avdtp_register_callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3b2882c4e47b122d8f26fd505bbf5f8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_abort_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a stream. </p>
<p>This function tries to suspend a stream by sending a request to the remote party. The stream can be in any state state except AVDTP_STREAM_STATE_IDLE. As a result of this operation the AVDTP_EVT_ABORT_STREAM_COMPLETED event will be generated. This operation cannot be rejected. The <code>evt_param.abort_stream_requested.err_code</code> is always == AVDTP_ERROR_SUCCESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaae73bd76bdea0c11165e3ababce488e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_add_media_rx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_media_packet_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a media packet buffer to a receive queue. </p>
<p>The consumer of AVDTP is responsible for allocating and supplying AVDTP with buffers used to store received packets. AVDTP itself only has a queue for storing pointers to buffers supplied by the consumer. When a packet comes in AVDTP finds the first buffer large enough to hold the received packet, copies the packet to the buffer and generates a AVDTP_EVT_MEDIA_PACKET_RECEIVED event. The consumer then has to process the data in the buffer and return it back to the queue. If there is no buffers in the queue or none of the buffers is large enough the received packets is dropped. Each buffer has a field (data_len) that holds the length of the received buffer. This field is never 0 if the buffer contains a packet. If a channel closed regardless of what has caused that and there are still buffers in the queue AVDTP generates a AVDTP_EVT_MEDIA_PACKET_RECEIVED event for each buffer and sets the data_len to 0. This is to inform the AVDTP consumer that the buffer has not been used and can be, for example, deallocated. This function adds a buffer to the receive queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga563a397fc0ec80d6dcd7f93c5ea4c9d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_add_media_tx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_media_packet_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a media packet buffer to a send queue. </p>
<p>When the consumer of AVDTP wants to send a packet to a remote device it calls this function. The function adds the packet to a queue and tells AVDTP that it has something to send. The packet will be send as soon as the stream goes to AVDTP_STREAM_STATE_STREAMING state. When the packet has been successfully sent a AVDTP_EVT_MEDIA_PACKET_SENT is generated. Otherwise a AVDTP_EVT_MEDIA_PACKET_SEND_FAILED is generated. Regardless of the event generated the consumer can re-use the buffer as AVDTP has removed it from the queue and gave up control over it. As in the case of received buffers, if a channel closed regardless of what has caused that and there are still buffers in the queue AVDTP generates a AVDTP_EVT_MEDIA_PACKET_SENT event for each buffer and sets the data_len field to 0. This is to inform the AVDTP consumer that the buffer has not been used and can be, for example, deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5f5030fc428a0d8245d7f725414443ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_avdtp_cancel_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>sep_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel listening for incoming connections. </p>
<p>This function removes a SEP from a list of SEPS which a stream can use for incoming requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">sep_id</td><td>Local SEP ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa183c4355d28d15e938a4a088c7a77fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_close_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a stream. </p>
<p>This function tries to close a stream by sending a request to the remote party. The stream has to be in AVDTP_STREAM_STATE_OPEN or AVDTP_STREAM_STATE_STREAMING state. As a result of this operation the AVDTP_EVT_CLOSE_STREAM_COMPLETED event will be generated. If the stream has been closed the <code>evt_param.bt_avdtp_evt_close_stream_completed_t.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to close the stream, the <code>evt_param.bt_avdtp_evt_close_stream_completed_t.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab49d03d6642d60ee5bb8628d1e96a088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_byte bt_avdtp_create_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream. </p>
<p>This function allocates memory for storing stream's data and assigns a stream handle. The stream handle is used to manipulate the stream - open, close, configure, suspend, abort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>Stream</code> handle if the function succeeds. </li>
<li><code>0</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad90fbc2862c2220022f113512b97e2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_destroy_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a stream. </p>
<p>This function frees memory used by the stream. The stream has to exist and be in the "idle" state for this function to succeed. I.e. the stream has to be closed or aborted before this function can be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2d7b41ff858c3930e8280d76dbbed835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>remote_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect from a remote device. </p>
<p>This function closes a control and transport channels on all streams associated with the remote device specified by the <code>remote_addr</code>. As a result of this operation the following events will be generated: </p><ul>
<li>AVDTP_EVT_MEDIA_PACKET_RECEIVED: if a stream's receive queue is not empty this event is generated for each buffer with bt_media_packet_t::data_len set to 0 </li>
<li>AVDTP_EVT_MEDIA_PACKET_SENT: if a stream's send queue is not empty this event is generated for each buffer with bt_media_packet_t::data_len set to 0 </li>
<li>AVDTP_EVT_STREAM_CLOSED: this event is generate if a stream is in "closing" state as a result of a request from the remote device or bt_avdtp_close_stream call before bt_avdtp_disconnect call </li>
<li>AVDTP_EVT_STREAM_ABORTED: this event is generated if a stream is in "active" state at the time of bt_avdtp_disconnect call.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if disconnection has been started. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7d3da0a9fa37246063d5f7c9688f9df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_discover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>remote_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover SEPs on a remote device. </p>
<p>This function asks the remote device to send a list of all available SEPs. As a result of this operation the following events will be generated: </p><ul>
<li>AVDTP_EVT_SEP_INFO_RECEIVED: this event is generated for every SEP received from the remote device. the <code>evt_param.sep_info_received</code> contains SEP information. </li>
<li>AVDTP_EVT_DISCOVER_COMPLETED: this event is generated after last AVDTP_EVT_SEP_INFO_RECEIVED if the remote accepted the request and the <code>evt_param.discover_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.discover_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if discover request has been sent. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9663f6647cd82a7afa2fbc0f40df9571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbt__avdtp__codec__t.html">bt_avdtp_codec_t</a>* bt_avdtp_find_codec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>codec_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a codec. </p>
<p>AVDTP in theory can support any type of codec. Each codec uses its own format for exchanging capabilities and configuration information. In order to make out implementation do not care about these formats we use a simple way of telling AVDTP how to parse and serialize codec's configuration. The consumer of AVDTP (e.g. A2DP) for each codec it wishes to support has to register a callback function (one per codec type). That callback has to perform two function. The first one is to read the configuration received from the remote device and store it in a structure defined by the consumer. The second one is to serialize the data from a structure to a format (in case of standard A2DP codecs the format is defined in A2DP specification, vendor specific codecs can define their own formats) suitable for sending as a part of a AVDTP request. This function returns a pointer to a structure that holds a pointer to a codec's callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">codec_type</td><td>Codec type. The codec_type can be one of the following values: <ul>
<li>AVDTP_CODEC_TYPE_SBC: SBC </li>
<li>AVDTP_CODEC_TYPE_MPEG1_2_AUDIO: MPEG-1,2 (used in MP3 files) </li>
<li>AVDTP_CODEC_TYPE_MPEG2_4_AAC: MPEG-2,4 AAC (used in Apple products) </li>
<li>AVDTP_CODEC_TYPE_ATRAC: ATRAC (used in Sony products) </li>
<li>AVDTP_CODEC_TYPE_NON_A2DP: Non-A2DP Codec</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails if a callback for a codec type specified in the <code>codec</code> parameter </li>
<li>has not been previously registered with bt_avdtp_register_codec. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga92da4c6c289f244cc2d797dd20a4ce93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_get_all_capabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>seid_acp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get remote SEP capabilities. </p>
<p>This function asks the remote device to send capabilities of a SEP specified by the <code>seid_acp</code>. As a result of this operation the following events will be generated: </p><ul>
<li>AVDTP_EVT_SEP_CAPABILITIES_RECEIVED: this event is generated if the remote device accepted the request. the <code>evt_param.sep_capabilities_received</code> contains SEP capabilities. </li>
<li>AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED: this event is generated right after AVDTP_EVT_SEP_CAPABILITIES_RECEIVED if the remote accepted the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">seid_acp</td><td>The ID of a remote SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if discover request has been sent. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadac43ab93b9bbfc44adb11d00432cac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_get_capabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>seid_acp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get remote SEP capabilities. </p>
<p>This function asks the remote device to send capabilities of a SEP specified by the <code>seid_acp</code>. As a result of this operation the following events will be generated: </p><ul>
<li>AVDTP_EVT_SEP_CAPABILITIES_RECEIVED: this event is generated if the remote device accepted the request. the <code>evt_param.sep_capabilities_received</code> contains SEP capabilities. </li>
<li>AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED: this event is generated right after AVDTP_EVT_SEP_CAPABILITIES_RECEIVED if the remote accepted the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">seid_acp</td><td>The ID of a remote SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if discover request has been sent. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf3e4c361ffa8d06e04502c9a8332e7c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_get_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream configuration. </p>
<p>This function requests stream configuration from a remote device. As a result of this operation the following events will be generated: </p><ul>
<li>AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED: this event is generated if the remote accepted the request. the <code>ebt_para.sep_capabilities_received.caps</code> will contain current stream configuration. </li>
<li>AVDTP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: If the remote accepted the request the <code>evt_param.get_stream_configuration_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.get_stream_configuration_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaeb053fd416a62a4ef9ccc9d591aca6c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_hci_conn_state_t* bt_avdtp_get_hci_connection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get HCI connection for a stream. </p>
<p>This function returns a pointer to a structure that describes an HCI connection a stream is open on. The return value can be used to call various function from the HCI layer. For example, if an app wants to force disconnection from a remote device it can call bt_hci_disconnect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>Pointer</code> to a structure that describes an HCI connection if the function succeeds. </li>
<li><code>NULL</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist or there is no HCI connection between local and remote devices associated with the stream.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has not been implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d6fcf341f66d243d5381c12c47eb7b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a>* bt_avdtp_get_mgr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to an instance of the AVDTP manager. </p>
<p>This function returns a pointer to an instance of the AVDTP manager. There is only one instance of the manager allocated by the stack. The pointer is passed as the first parameter to all AVDTP functions. </p>

</div>
</div>
<a class="anchor" id="ga3326bc00ab3d922aeb8771b0ca6206f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_avdtp_sep_t* bt_avdtp_get_sep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>sep_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a SEP info by its ID. </p>
<p>This function returns a pointer to bt_avdtp_sep_t structure that describes a SEP previously registered with bt_avdtp_register_sep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">sep_id</td><td>The ID of a SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>Pointer</code> to bt_avdtp_sep_t if the SEP is in the list of registered SEPs. </li>
<li><code>NULL</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gade095bf025f9fb35c93613ecf758ce02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bt_avdtp_get_stream_codec_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configuration of the codec currently used with the stream. </p>
<p>This function returns a pointer to a structure that contains configuration of the codec currently used with the stream. The structure returned depends on the codec. The dotstack defines structures only for SBC, MPEG-1,2 and MPEG-2,4 AAC codecs: </p><ul>
<li>SBC: <a class="el" href="structbt__a2dp__sbc__config__t.html">bt_a2dp_sbc_config_t</a> (defined in a2dp_sbc_codec.h) </li>
<li>MPEG-1,2: <a class="el" href="structbt__a2dp__mpeg__config__t.html">bt_a2dp_mpeg_config_t</a> (defined in a2dp_mpeg_codec.h) </li>
<li>MPEG-2,4 AAC: <a class="el" href="structbt__a2dp__aac__config__t.html">bt_a2dp_aac_config_t</a> (defined in a2dp_aac_codec.h)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The codec's configuration if strm_handle specifies a valid stream and the stream is in one of the following state: <pre class="fragment">    AVDTP_STREAM_STATE_CONFIGURED
    AVDTP_STREAM_STATE_OPEN
    AVDTP_STREAM_STATE_STREAMING

    \li NULL otherwise.</pre> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga450ff68934f53a6c2ddaeb0cca29fab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_byte bt_avdtp_get_stream_codec_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the codec currently used with the stream. </p>
<p>This function returns the type of the codec currently used with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The type of the codec if strm_handle specifies a valid stream and the stream is in one of the following states: <pre class="fragment">      AVDTP_STREAM_STATE_CONFIGURED
      AVDTP_STREAM_STATE_OPEN
      AVDTP_STREAM_STATE_STREAMING

    @arg The result will be one of the following values:

       AVDTP_CODEC_TYPE_SBC:           SBC
       AVDTP_CODEC_TYPE_MPEG1_2_AUDIO: MPEG-1,2 (used in MP3 files)
       AVDTP_CODEC_TYPE_MPEG2_4_AAC:   MPEG-2,4 AAC (used in Apple products)
       AVDTP_CODEC_TYPE_ATRAC:         ATRAC (used in Sony products)
       AVDTP_CODEC_TYPE_NON_A2DP:      Non-A2DP Codec

    @arg 0xFF otherwise.</pre> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga399121298592a0f75073b437e0dfd6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a>* bt_avdtp_get_stream_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's configuration. </p>
<p>This function returns a pointer to a structure holding the current configuration of stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The stream's configuration if strm_handle specifies a valid stream and the stream is in one of the following state: <pre class="fragment">    AVDTP_STREAM_STATE_CONFIGURED
    AVDTP_STREAM_STATE_OPEN
    AVDTP_STREAM_STATE_STREAMING

    \li NULL otherwise.</pre> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae3ba4a1f9d3a9d91268cf66aa9afd589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_byte bt_avdtp_get_stream_local_sep_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's local SEP ID. </p>
<p>This function returns the ID of the local SEP associated with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The ID of the local SEP if strm_handle specifies a valid stream. </li>
<li>0 otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab67ac3b6a1501e1cba70af33172dfa1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bdaddr_t* bt_avdtp_get_stream_remote_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's remote BT address. </p>
<p>This function returns the address of the remote device associated with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The address of the remote device if strm_handle specifies a valid stream. </li>
<li>NULL otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa7135cde7501a2ec46b2921169b68599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_byte bt_avdtp_get_stream_remote_sep_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's remote SEP ID. </p>
<p>This function returns the ID of the remote SEP associated with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The ID of the remote SEP if strm_handle specifies a valid stream. </li>
<li>0 otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaed4fd0933472235f2ffa1594daccde7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_byte bt_avdtp_get_stream_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get local stream state. </p>
<p>This function returns local state of a stream specified by the <code>strm_handle</code>. No request is sent to the remote party.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of the stream. The result will be one of the following values: <ul>
<li>AVDTP_STREAM_STATE_IDLE: The stream is idle. This can mean two things. The stream specified by <code>strm_handle</code> does not exist or the stream is closed. </li>
<li>AVDTP_STREAM_OPENING_TRANSPORT_CHANNELS: The stream is opening transport channels. </li>
<li>AVDTP_STREAM_CLOSING_TRANSPORT_CHANNELS: The stream is closing transport channels. </li>
<li>AVDTP_STREAM_STATE_CONFIGURED: The stream has been configured. </li>
<li>AVDTP_STREAM_STATE_OPEN: The stream has been opened. </li>
<li>AVDTP_STREAM_STATE_STREAMING: The stream has been started. Depending on the local SEP type (source or sink) it means that the stream is can send or receive media packets. </li>
<li>AVDTP_STREAM_STATE_CLOSING: The stream is closing. This means that all transport channels associated with the stream are being closed. After they have been closed the stream goes to AVDTP_STREAM_STATE_IDLE state. </li>
<li>AVDTP_STREAM_STATE_ABORTING: The stream is aborting. This means that all transport channels associated with the stream are being closed. After they have been closed the stream goes to AVDTP_STREAM_STATE_IDLE state. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga265589188d09517322530a2933850acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_avdtp_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the AVDTP layer. </p>
<p>This function initializes the AVDTP layer of the stack. It must be called prior to any other AVDTP function can be called. </p>

</div>
</div>
<a class="anchor" id="gac078d38da081ad5112b5992c66c37c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>sep_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for incoming connections. </p>
<p>This function tells a stream that it can use a particular SEP to accept incoming requests to open it. The SEP can be associated with multiple streams but used with only one. The stream has to be closed before the SEP can be used with another stream. For outgoing connections this is not needed. Any SEP can be used with any stream given that the SEP is not already in use by another stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">sep_id</td><td>Local SEP ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae826060d50bea1cea37e02cb899af46f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_open_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a stream. </p>
<p>This function tries to open a stream by sending a request to the remote party. The stream has to be already configured with a bt_avdtp_set_configuration call. As a result of this operation the AVDTP_EVT_OPEN_STREAM_COMPLETED event will be generated. If the stream has been open the <code>evt_param.open_stream_completed.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to open the stream, the <code>evt_param.open_stream_completed.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac3d853c711364c8f50f2d29a758cffcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_reconfigure_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure stream. </p>
<p>This function tries to change the stream's configuration. For this function to succeed the stream has to be open. As a result of this operation the AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED event will be generated. If reconfiguration was a success the <code>evt_param.stream_reconfigure_completed.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise the <code>evt_param.stream_reconfigure_completed.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">caps</td><td>New stream configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5a41da0e2cb8e036e4598ee2cd1340fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_avdtp_register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avdtp.html#gad2d105a7645343cec9c5da702afaa844">bt_avdtp_mgr_callback_fp</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a AVDTP application callback. </p>
<p>In order to be notified of various events a consumer of the AVDTP layer has to register a callback function. The stack will call this function whenever a new event has been generated passing the code of the event as the second parameter. The event can be one of the following values:</p>
<ul>
<li>AVDTP_EVT_CTRL_CHANNEL_CONNECTED: Control channel connected. </li>
<li>AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED: Control channel disconnected. </li>
<li>AVDTP_EVT_CTRL_CONNECTION_FAILED: Control channel connection failed (generated only if control connection has been initiated by the local device). </li>
<li>AVDTP_EVT_DISCOVER_COMPLETED: Local device completed discovering remote SEPs. </li>
<li>AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED: Local device received a response to Get SEP capabilities operation. </li>
<li>AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Set stream configuration operation. </li>
<li>AVDTP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Get stream configuration operation. </li>
<li>AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED: Local device received a response to Reconfigure stream operation. </li>
<li>AVDTP_EVT_OPEN_STREAM_COMPLETED: Local device received a response to Open stream operation. </li>
<li>AVDTP_EVT_START_STREAM_COMPLETED: Local device received a response to Start stream operation. </li>
<li>AVDTP_EVT_CLOSE_STREAM_COMPLETED: Local device received a response to Close stream operation. </li>
<li>AVDTP_EVT_SUSPEND_STREAM_COMPLETED: Local device received a response to Suspend stream operation. </li>
<li>AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED: Local device received a response to Stream security control operation. </li>
<li>AVDTP_EVT_ABORT_STREAM_COMPLETED: Local device received a response to Abort stream operation. </li>
<li>AVDTP_EVT_SEP_INFO_RECEIVED: SEP information received. </li>
<li>AVDTP_EVT_SEP_CAPABILITIES_RECEIVED: SEP capabilities received. </li>
<li>AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED: Stream configuration received.</li>
</ul>
<ul>
<li>AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED: Remote device requested stream configuration. </li>
<li>AVDTP_EVT_OPEN_STREAM_REQUESTED: Remote device requested to open a stream. </li>
<li>AVDTP_EVT_START_STREAM_REQUESTED: Remote device requested to start a stream. </li>
<li>AVDTP_EVT_CLOSE_STREAM_REQUESTED: Remote device requested to close a stream. </li>
<li>AVDTP_EVT_SUSPEND_STREAM_REQUESTED: Remote device requested to suspend a stream. </li>
<li>AVDTP_EVT_ABORT_STREAM_REQUESTED: Remote device requested to abort a stream. </li>
<li>AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED: Remote device requested to reconfigure a stream. </li>
<li>AVDTP_EVT_MEDIA_PACKET_RECEIVED: Remote device sent a media packet. </li>
<li>AVDTP_EVT_STREAM_CONFIGURED: A stream has been configured (This event is generated right after AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_RECONFIGURED: A stream has been re-configured (This event is generated right after AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_OPENED: A stream has been opened (This event is generated as a result of local or remote stream opening request). </li>
<li>AVDTP_EVT_STREAM_STARTED: A stream has been started (This event is generated right after AVDTP_EVT_START_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_CLOSED: A stream has been close (This event is generated right after AVDTP_EVT_CLOSE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_SUSPENDED: A stream has been suspended (This event is generated right after AVDTP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>AVDTP_EVT_STREAM_ABORTED: A stream has been aborted (This event is generated right after AVDTP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request. It is also generated if connection between devices has been terminated by means other than AVDTP signaling, e.g. devices going out of rage). </li>
<li>AVDTP_EVT_MEDIA_PACKET_SENT: The local device has successfully sent a media packet to the remote device. </li>
<li>AVDTP_EVT_MEDIA_PACKET_SEND_FAILED: The local device was not able to send a media packet to the remote device.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when the AVDTP generates an event. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35b9313048cf22068276f9dc5505debb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_register_codec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__codec__t.html">bt_avdtp_codec_t</a> *&#160;</td>
          <td class="paramname"><em>codec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a codec. </p>
<p>AVDTP in theory can support any type of codec. Each codec uses its own format for exchanging capabilities and configuration information. In order to make out implementation do not care about these formats we use a simple way of telling AVDTP how to parse and serialize codec's configuration. The consumer of AVDTP (e.g. A2DP) for each codec it wishes to support has to register a callback function (one per codec type). That callback has to perform two function. The first one is to read the configuration received from the remote device and store it in a structure defined by the consumer. The second one is to serialize the data from a structure to a format (in case of standard A2DP codecs the format is defined in A2DP specification, vendor specific codecs can define their own formats) suitable for sending as a part of a AVDTP request. This function adds a codec's callback function to an internal list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">codec</td><td>Pointer to a structure specifying codec type and a callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails if there already is a callback for a codec type specified in the <code>codec</code> parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8fc5552470ee84924d0e5fe300e1ef67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_byte bt_avdtp_register_sep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a SEP with the local AVDTP manager. </p>
<p>This function is used to make a list of SEPs supported by the local ADVTP entity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">type</td><td>The type of a SEP. The type can be one of the following values: <ul>
<li>AVDTP_SEP_TYPE_SOURCE: The SEP is a source. </li>
<li>AVDTP_SEP_TYPE_SINK: The SEP is a sink. </li>
</ul>
</td></tr>
    <tr><td class="paramname">caps</td><td>The capabilities of a SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>ID</code> of a SEP if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga30ac93f097aa119c492c1e82bdb083bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_remove_media_rx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_media_packet_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a media packet buffer from a receive queue. </p>
<p>The consumer of AVDTP is responsible for allocating and supplying AVDTP with buffers used to store received packets. AVDTP itself only has a queue for storing pointers to buffers supplied by the consumer. When a packet comes in AVDTP finds the first buffer large enough to hold the received packet, copies the packet to the buffer and generates a AVDTP_EVT_MEDIA_PACKET_RECEIVED event. The consumer then has to process the data in the buffer and return it back to the queue. If there is no buffers in the queue or none of the buffers is large enough the received packets is dropped. Each buffer has a field (data_len) that holds the length of the received buffer. This field is never 0 if the buffer contains a packet. If a channel closed regardless of what has caused that and there are still buffers in the queue AVDTP generates a AVDTP_EVT_MEDIA_PACKET_RECEIVED event for each buffer and sets the data_len to 0. This is to inform the AVDTP consumer that the buffer has not been used and can be, for example, deallocated. This function removes a buffer from the receive queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3cfff55df797f6d235f9ad5a8313a608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_remove_media_tx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_media_packet_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a media packet buffer from a send queue. </p>
<p>When the consumer of AVDTP wants to send a packet to a remote device it calls bt_avdtp_add_media_tx_buffer function. The function adds the packet to a queue and tells AVDTP that it has something to send. The packet will be send as soon as the stream goes to AVDTP_STREAM_STATE_STREAMING state. The consumer has a chance to remove a packet from the queue before it has been sent to a remote device by calling bt_avdtp_remove_media_tx_buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has not been implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2895ca6383742f0df37422ac6fb3652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_report_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_uint&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report delay value of a Sink to a Source. </p>
<p>This function sends the delay value of a Sink to a Source. This enables synchronous playback of audio and video. Delay reports are always sent from the Sink to the Source. If the Sink's delay report has been accepted by the Source the <code>evt_param.delay_report_completed.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise the <code>evt_param.delay_report_completed.err_code</code> == the error code sent by the Source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">delay</td><td>The delay value in 1/10 milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab06ed7034f7742a739de18472f88b99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_security_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte *&#160;</td>
          <td class="paramname"><em>sc_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>sc_data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange content protection control data. </p>
<p>This function tries to establish content protection by sending a request to the remote party. The stream can be in any state state except AVDTP_STREAM_STATE_IDLE, AVDTP_STREAM_STATE_CLOSING, AVDTP_STREAM_STATE_ABORTING. As a result of this operation the AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED event will be generated. If the stream's content protection data has been accepted by the remote party the <code>evt_param.security_control_completed.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise the <code>evt_param.security_control_completed.err_code</code> == the error code sent by the remote.</p>
<dl class="section note"><dt>Note</dt><dd>The dotstack does not support content protection. Although the request can be sent it will not affect the operation of the AVDTP in any way.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad75052b1810022b4aa5a9b61f8789080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_set_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>seid_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>seid_acp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stream configuration. </p>
<p>This function tries to configure a stream before opening it. As a result of this operation the AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event will be generated. If configuration was a success the <code>evt_param.set_stream_configuration_completed.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise the <code>evt_param.set_stream_configuration_completed.err_code</code> == the error code sent by the remote and <code>evt_param.set_stream_configuration_completed.svc_category</code> == the value of the first Service Category to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">seid_int</td><td>Local SEP ID. </td></tr>
    <tr><td class="paramname">seid_acp</td><td>Remote SEP ID. </td></tr>
    <tr><td class="paramname">caps</td><td>Stream configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga274a948661f9e1902278a76b8259ea94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the AVDTP layer. </p>
<p>This function makes the AVDTP layer ready to accept connection requests from remote device. To make an outgoing connection calling this function is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae463a1e025414d880c758865b5d34443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_start_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a stream. </p>
<p>This function tries to start a stream by sending a request to the remote party. The stream has to be in AVDTP_STREAM_STATE_OPEN state. The stream goes to this state as a result of successful configuration or suspension (both can be initiated by either party). As a result of this operation the AVDTP_EVT_START_STREAM_COMPLETED event will be generated. If the stream has been open the <code>evt_param.start_stream_requested.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to start the stream, the <code>evt_param.start_stream_requested.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad180fe6c3657b0fc2367faaf33146e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_suspend_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a stream. </p>
<p>This function tries to suspend a stream by sending a request to the remote party. The stream has to be in AVDTP_STREAM_STATE_STREAMING state. As a result of this operation the AVDTP_EVT_SUSPEND_STREAM_COMPLETED event will be generated. If the stream has been suspended the <code>evt_param.bt_avdtp_evt_suspend_stream_requested_t.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to suspend the stream, the <code>evt_param.bt_avdtp_evt_suspend_stream_requested_t.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga38e53a1c3a158967a2d15a61e6e25546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_avdtp_unregister_codec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__avdtp__mgr__t.html">bt_avdtp_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>codec_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a codec. </p>
<p>AVDTP in theory can support any type of codec. Each codec uses its own format for exchanging capabilities and configuration information. In order to make out implementation do not care about these formats we use a simple way of telling AVDTP how to parse and serialize codec's configuration. The consumer of AVDTP (e.g. A2DP) for each codec it wishes to support has to register a callback function (one per codec type). That callback has to perform two function. The first one is to read the configuration received from the remote device and store it in a structure defined by the consumer. The second one is to serialize the data from a structure to a format (in case of standard A2DP codecs the format is defined in A2DP specification, vendor specific codecs can define their own formats) suitable for sending as a part of a AVDTP request. This function removes a codec's callback function from an internal list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">codec_type</td><td>Codec type. The codec_type can be one of the following values: <ul>
<li>AVDTP_CODEC_TYPE_SBC: SBC </li>
<li>AVDTP_CODEC_TYPE_MPEG1_2_AUDIO: MPEG-1,2 (used in MP3 files) </li>
<li>AVDTP_CODEC_TYPE_MPEG2_4_AAC: MPEG-2,4 AAC (used in Apple products) </li>
<li>AVDTP_CODEC_TYPE_ATRAC: ATRAC (used in Sony products) </li>
<li>AVDTP_CODEC_TYPE_NON_A2DP: Non-A2DP Codec</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails if a callback for a codec type specified in the <code>codec</code> parameter </li>
<li>has not been previously registered with bt_avdtp_register_codec. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>Copyright &copy; 2015 SEARAN LLC. All right reserved.</small></address>
</body>
</html>
