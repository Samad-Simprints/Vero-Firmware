<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>dotstack API Reference: Advanced Audio Distribution Profile (A2DP)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dotstack API Reference
   &#160;<span id="projectnumber">1.8.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Advanced Audio Distribution Profile (A2DP)</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Advanced Audio Distribution Profile (A2DP) defines the protocols and procedures that realize distribution of audio content of high-quality in mono or stereo on ACL channels.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__a2dp__evt__open__and__start__stream__completed__t.html">bt_a2dp_evt_open_and_start_stream_completed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED event.  <a href="structbt__a2dp__evt__open__and__start__stream__completed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union__bt__a2dp__event__u.html">bt_a2dp_event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to an application callback.  <a href="union__bt__a2dp__event__u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bt__a2dp__mgr__t.html">bt_a2dp_mgr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A2DP manager.  <a href="struct__bt__a2dp__mgr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga66343282e7c6d52d7bd604e29ab18cc3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga66343282e7c6d52d7bd604e29ab18cc3">bt_a2dp_find_codec</a>(mgr,  codec_type)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga9663f6647cd82a7afa2fbc0f40df9571">bt_avdtp_find_codec</a>(mgr-&gt;avdtp_mgr, codec_type)</td></tr>
<tr class="memdesc:ga66343282e7c6d52d7bd604e29ab18cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a codec.  <a href="#ga66343282e7c6d52d7bd604e29ab18cc3">More...</a><br /></td></tr>
<tr class="separator:ga66343282e7c6d52d7bd604e29ab18cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa787176a321c0f101abb10e9d7b37bc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa787176a321c0f101abb10e9d7b37bc9">bt_a2dp_connect</a>(mgr,  remote_addr)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gadc565b71c9d76e8a3c6c838436605b83">bt_avdtp_connect</a>(mgr-&gt;avdtp_mgr, remote_addr)</td></tr>
<tr class="memdesc:gaa787176a321c0f101abb10e9d7b37bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote device.  <a href="#gaa787176a321c0f101abb10e9d7b37bc9">More...</a><br /></td></tr>
<tr class="separator:gaa787176a321c0f101abb10e9d7b37bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9d178b56d8701221d39126157b30b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga2e9d178b56d8701221d39126157b30b3">bt_a2dp_connect_ex</a>(mgr,  remote_addr,  acl_config)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga258c796e3a420d6fc29d10035fe47cd9">bt_avdtp_connect_ex</a>(mgr-&gt;avdtp_mgr, remote_addr, acl_config)</td></tr>
<tr class="memdesc:ga2e9d178b56d8701221d39126157b30b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote device.  <a href="#ga2e9d178b56d8701221d39126157b30b3">More...</a><br /></td></tr>
<tr class="separator:ga2e9d178b56d8701221d39126157b30b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8391ae990eca2b62adb0b1170f8b7cc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga8391ae990eca2b62adb0b1170f8b7cc1">bt_a2dp_disconnect</a>(mgr,  remote_addr)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga2d7b41ff858c3930e8280d76dbbed835">bt_avdtp_disconnect</a>(mgr-&gt;avdtp_mgr, remote_addr)</td></tr>
<tr class="memdesc:ga8391ae990eca2b62adb0b1170f8b7cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from a remote device.  <a href="#ga8391ae990eca2b62adb0b1170f8b7cc1">More...</a><br /></td></tr>
<tr class="separator:ga8391ae990eca2b62adb0b1170f8b7cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2093746741e62a8c3931e1bf2d6323b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaf2093746741e62a8c3931e1bf2d6323b">bt_a2dp_register_sink</a>(mgr,  caps)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga8fc5552470ee84924d0e5fe300e1ef67">bt_avdtp_register_sep</a>(mgr-&gt;avdtp_mgr, <a class="el" href="group__avdtp.html#ga5f99e5a9c4f03230a3d1648231edf3ed">AVDTP_SEP_TYPE_SINK</a>, caps)</td></tr>
<tr class="memdesc:gaf2093746741e62a8c3931e1bf2d6323b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a Sink SEP with the local A2DP manager.  <a href="#gaf2093746741e62a8c3931e1bf2d6323b">More...</a><br /></td></tr>
<tr class="separator:gaf2093746741e62a8c3931e1bf2d6323b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5932000482e9cf7aa177499b3f2e6a97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga5932000482e9cf7aa177499b3f2e6a97">bt_a2dp_register_source</a>(mgr,  caps)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga8fc5552470ee84924d0e5fe300e1ef67">bt_avdtp_register_sep</a>(mgr-&gt;avdtp_mgr, <a class="el" href="group__avdtp.html#gaad17a1d784c3581a823fbd5bcbe617f8">AVDTP_SEP_TYPE_SOURCE</a>, caps)</td></tr>
<tr class="memdesc:ga5932000482e9cf7aa177499b3f2e6a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a Source SEP with the local A2DP manager.  <a href="#ga5932000482e9cf7aa177499b3f2e6a97">More...</a><br /></td></tr>
<tr class="separator:ga5932000482e9cf7aa177499b3f2e6a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf58af894cb3667bbc54517418b820b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga5cf58af894cb3667bbc54517418b820b">bt_a2dp_discover</a>(mgr,  remote_addr)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga7d3da0a9fa37246063d5f7c9688f9df4">bt_avdtp_discover</a>(mgr-&gt;avdtp_mgr, remote_addr)</td></tr>
<tr class="memdesc:ga5cf58af894cb3667bbc54517418b820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover SEPs on a remote device.  <a href="#ga5cf58af894cb3667bbc54517418b820b">More...</a><br /></td></tr>
<tr class="separator:ga5cf58af894cb3667bbc54517418b820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfe176f0d104300280b99f98f0de3762"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gabfe176f0d104300280b99f98f0de3762">bt_a2dp_get_capabilities</a>(mgr,  remote_addr,  seid_acp)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gadac43ab93b9bbfc44adb11d00432cac8">bt_avdtp_get_capabilities</a>(mgr-&gt;avdtp_mgr, remote_addr, seid_acp)</td></tr>
<tr class="memdesc:gabfe176f0d104300280b99f98f0de3762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remote SEP capabilities.  <a href="#gabfe176f0d104300280b99f98f0de3762">More...</a><br /></td></tr>
<tr class="separator:gabfe176f0d104300280b99f98f0de3762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf6975403e1593baa0c1c9da69fcf08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga1bf6975403e1593baa0c1c9da69fcf08">bt_a2dp_get_all_capabilities</a>(mgr,  remote_addr,  seid_acp)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga92da4c6c289f244cc2d797dd20a4ce93">bt_avdtp_get_all_capabilities</a>(mgr-&gt;avdtp_mgr, remote_addr, seid_acp)</td></tr>
<tr class="memdesc:ga1bf6975403e1593baa0c1c9da69fcf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remote SEP capabilities.  <a href="#ga1bf6975403e1593baa0c1c9da69fcf08">More...</a><br /></td></tr>
<tr class="separator:ga1bf6975403e1593baa0c1c9da69fcf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad534e9a5d37032540a4934d430bfe92d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gad534e9a5d37032540a4934d430bfe92d">bt_a2dp_create_stream</a>(mgr)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gab49d03d6642d60ee5bb8628d1e96a088">bt_avdtp_create_stream</a>(mgr-&gt;avdtp_mgr)</td></tr>
<tr class="memdesc:gad534e9a5d37032540a4934d430bfe92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream.  <a href="#gad534e9a5d37032540a4934d430bfe92d">More...</a><br /></td></tr>
<tr class="separator:gad534e9a5d37032540a4934d430bfe92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d14d1256b380638c015c166056755d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga6d14d1256b380638c015c166056755d2">bt_a2dp_destroy_stream</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gad90fbc2862c2220022f113512b97e2be">bt_avdtp_destroy_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga6d14d1256b380638c015c166056755d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a stream.  <a href="#ga6d14d1256b380638c015c166056755d2">More...</a><br /></td></tr>
<tr class="separator:ga6d14d1256b380638c015c166056755d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60d8fb5ced62f92bfa88f93ac7d9040"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa60d8fb5ced62f92bfa88f93ac7d9040">bt_a2dp_listen</a>(mgr,  strm_handle,  sep_id)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac078d38da081ad5112b5992c66c37c9f">bt_avdtp_listen</a>(mgr-&gt;avdtp_mgr, strm_handle, sep_id)</td></tr>
<tr class="memdesc:gaa60d8fb5ced62f92bfa88f93ac7d9040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for incoming connections.  <a href="#gaa60d8fb5ced62f92bfa88f93ac7d9040">More...</a><br /></td></tr>
<tr class="separator:gaa60d8fb5ced62f92bfa88f93ac7d9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5084e7a6d925f30dee5fa66bd2c68400"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga5084e7a6d925f30dee5fa66bd2c68400">bt_a2dp_cancel_listen</a>(mgr,  strm_handle,  sep_id)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga5f5030fc428a0d8245d7f725414443ec">bt_avdtp_cancel_listen</a>(mgr-&gt;avdtp_mgr, strm_handle, sep_id)</td></tr>
<tr class="memdesc:ga5084e7a6d925f30dee5fa66bd2c68400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel listening for incoming connections.  <a href="#ga5084e7a6d925f30dee5fa66bd2c68400">More...</a><br /></td></tr>
<tr class="separator:ga5084e7a6d925f30dee5fa66bd2c68400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83031dd62c1b4694e5159ff52082768c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga83031dd62c1b4694e5159ff52082768c">bt_a2dp_reconfigure_stream</a>(mgr,  strm_handle,  caps)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac3d853c711364c8f50f2d29a758cffcf">bt_avdtp_reconfigure_stream</a>(mgr-&gt;avdtp_mgr, strm_handle, caps)</td></tr>
<tr class="memdesc:ga83031dd62c1b4694e5159ff52082768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure stream.  <a href="#ga83031dd62c1b4694e5159ff52082768c">More...</a><br /></td></tr>
<tr class="separator:ga83031dd62c1b4694e5159ff52082768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a92fc8861b1682d6b2cac689a7e703"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gab7a92fc8861b1682d6b2cac689a7e703">bt_a2dp_get_stream_state</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaed4fd0933472235f2ffa1594daccde7c">bt_avdtp_get_stream_state</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:gab7a92fc8861b1682d6b2cac689a7e703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local stream state.  <a href="#gab7a92fc8861b1682d6b2cac689a7e703">More...</a><br /></td></tr>
<tr class="separator:gab7a92fc8861b1682d6b2cac689a7e703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2c5e4a274efa5d733e4fbee85f3f78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga0f2c5e4a274efa5d733e4fbee85f3f78">bt_a2dp_get_stream_local_sep_id</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gae3ba4a1f9d3a9d91268cf66aa9afd589">bt_avdtp_get_stream_local_sep_id</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga0f2c5e4a274efa5d733e4fbee85f3f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's local SEP ID.  <a href="#ga0f2c5e4a274efa5d733e4fbee85f3f78">More...</a><br /></td></tr>
<tr class="separator:ga0f2c5e4a274efa5d733e4fbee85f3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b96c8d3f7d27fce5d7d948fb91ac40e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga9b96c8d3f7d27fce5d7d948fb91ac40e">bt_a2dp_get_stream_remote_sep_id</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaa7135cde7501a2ec46b2921169b68599">bt_avdtp_get_stream_remote_sep_id</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga9b96c8d3f7d27fce5d7d948fb91ac40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's remote SEP ID.  <a href="#ga9b96c8d3f7d27fce5d7d948fb91ac40e">More...</a><br /></td></tr>
<tr class="separator:ga9b96c8d3f7d27fce5d7d948fb91ac40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0650e870e5bb7cc4bd41e6c0ad22f69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa0650e870e5bb7cc4bd41e6c0ad22f69">bt_a2dp_get_stream_remote_address</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gab67ac3b6a1501e1cba70af33172dfa1a">bt_avdtp_get_stream_remote_address</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:gaa0650e870e5bb7cc4bd41e6c0ad22f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's remote BT address.  <a href="#gaa0650e870e5bb7cc4bd41e6c0ad22f69">More...</a><br /></td></tr>
<tr class="separator:gaa0650e870e5bb7cc4bd41e6c0ad22f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad264bf656fbf078e00113546afc21b8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gad264bf656fbf078e00113546afc21b8c">bt_a2dp_get_stream_codec_type</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga450ff68934f53a6c2ddaeb0cca29fab7">bt_avdtp_get_stream_codec_type</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:gad264bf656fbf078e00113546afc21b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the codec currently used with the stream.  <a href="#gad264bf656fbf078e00113546afc21b8c">More...</a><br /></td></tr>
<tr class="separator:gad264bf656fbf078e00113546afc21b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23fb6d8e2a44ab1cc9ab8fbd50de885f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga23fb6d8e2a44ab1cc9ab8fbd50de885f">bt_a2dp_get_stream_codec_config</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gade095bf025f9fb35c93613ecf758ce02">bt_avdtp_get_stream_codec_config</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga23fb6d8e2a44ab1cc9ab8fbd50de885f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configuration of the codec currently used with the stream.  <a href="#ga23fb6d8e2a44ab1cc9ab8fbd50de885f">More...</a><br /></td></tr>
<tr class="separator:ga23fb6d8e2a44ab1cc9ab8fbd50de885f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059e4d447d77f8c988a90c05212625b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga059e4d447d77f8c988a90c05212625b0">bt_avdtp_get_stream_config</a>(mgr,  strm_handle)&#160;&#160;&#160;bt_avdtp_get_stream_config(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga059e4d447d77f8c988a90c05212625b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream's configuration.  <a href="#ga059e4d447d77f8c988a90c05212625b0">More...</a><br /></td></tr>
<tr class="separator:ga059e4d447d77f8c988a90c05212625b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52af0a8b6815b2b00767edd7e73c6cf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga52af0a8b6815b2b00767edd7e73c6cf2">bt_a2dp_start_stream</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gae463a1e025414d880c758865b5d34443">bt_avdtp_start_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga52af0a8b6815b2b00767edd7e73c6cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a stream.  <a href="#ga52af0a8b6815b2b00767edd7e73c6cf2">More...</a><br /></td></tr>
<tr class="separator:ga52af0a8b6815b2b00767edd7e73c6cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b248664684a3ebb401855112e79f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gadf2b248664684a3ebb401855112e79f2">bt_a2dp_close_stream</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaa183c4355d28d15e938a4a088c7a77fd">bt_avdtp_close_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:gadf2b248664684a3ebb401855112e79f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a stream.  <a href="#gadf2b248664684a3ebb401855112e79f2">More...</a><br /></td></tr>
<tr class="separator:gadf2b248664684a3ebb401855112e79f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1cb8ff862d38c1520a089945bf8622"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga4e1cb8ff862d38c1520a089945bf8622">bt_a2dp_suspend_stream</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gad180fe6c3657b0fc2367faaf33146e80">bt_avdtp_suspend_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga4e1cb8ff862d38c1520a089945bf8622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a stream.  <a href="#ga4e1cb8ff862d38c1520a089945bf8622">More...</a><br /></td></tr>
<tr class="separator:ga4e1cb8ff862d38c1520a089945bf8622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad305d643b5e8fa8dd3df0e087b0dcc80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gad305d643b5e8fa8dd3df0e087b0dcc80">bt_a2dp_abort_stream</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga3b2882c4e47b122d8f26fd505bbf5f8a">bt_avdtp_abort_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:gad305d643b5e8fa8dd3df0e087b0dcc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a stream.  <a href="#gad305d643b5e8fa8dd3df0e087b0dcc80">More...</a><br /></td></tr>
<tr class="separator:gad305d643b5e8fa8dd3df0e087b0dcc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7649bee07a84e3c0eeda24d72adda8f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga7649bee07a84e3c0eeda24d72adda8f9">bt_a2dp_get_hci_connection</a>(mgr,  strm_handle)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaeb053fd416a62a4ef9ccc9d591aca6c2">bt_avdtp_get_hci_connection</a>(mgr-&gt;avdtp_mgr, strm_handle)</td></tr>
<tr class="memdesc:ga7649bee07a84e3c0eeda24d72adda8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get HCI connection for a stream.  <a href="#ga7649bee07a84e3c0eeda24d72adda8f9">More...</a><br /></td></tr>
<tr class="separator:ga7649bee07a84e3c0eeda24d72adda8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21b8afb1fad71e22f75d199bd992944"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gad21b8afb1fad71e22f75d199bd992944">bt_a2dp_add_media_rx_buffer</a>(mgr,  strm_handle,  buffer)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaae73bd76bdea0c11165e3ababce488e4">bt_avdtp_add_media_rx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td></tr>
<tr class="memdesc:gad21b8afb1fad71e22f75d199bd992944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a media packet buffer to a receive queue.  <a href="#gad21b8afb1fad71e22f75d199bd992944">More...</a><br /></td></tr>
<tr class="separator:gad21b8afb1fad71e22f75d199bd992944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c2673e6b92dba672c28dc084b39741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga45c2673e6b92dba672c28dc084b39741">bt_a2dp_remove_media_rx_buffer</a>(mgr,  strm_handle,  buffer)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga30ac93f097aa119c492c1e82bdb083bf">bt_avdtp_remove_media_rx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td></tr>
<tr class="memdesc:ga45c2673e6b92dba672c28dc084b39741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a media packet buffer from a receive queue.  <a href="#ga45c2673e6b92dba672c28dc084b39741">More...</a><br /></td></tr>
<tr class="separator:ga45c2673e6b92dba672c28dc084b39741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4617776126236643c24411cdbd1808af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga4617776126236643c24411cdbd1808af">bt_a2dp_add_media_tx_buffer</a>(mgr,  strm_handle,  buffer)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga563a397fc0ec80d6dcd7f93c5ea4c9d8">bt_avdtp_add_media_tx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td></tr>
<tr class="memdesc:ga4617776126236643c24411cdbd1808af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a media packet buffer to a send queue.  <a href="#ga4617776126236643c24411cdbd1808af">More...</a><br /></td></tr>
<tr class="separator:ga4617776126236643c24411cdbd1808af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14adc22169f6c3d48d160f3427c88bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa14adc22169f6c3d48d160f3427c88bf">bt_a2dp_remove_media_tx_buffer</a>(mgr,  strm_handle,  buffer)&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga3cfff55df797f6d235f9ad5a8313a608">bt_avdtp_remove_media_tx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td></tr>
<tr class="memdesc:gaa14adc22169f6c3d48d160f3427c88bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a media packet buffer from a send queue.  <a href="#gaa14adc22169f6c3d48d160f3427c88bf">More...</a><br /></td></tr>
<tr class="separator:gaa14adc22169f6c3d48d160f3427c88bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf83cd7be39b6efef38709edb06300c33"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaf83cd7be39b6efef38709edb06300c33">bt_a2dp_find_server_callback_fp</a>) (bt_uint supported_features, bt_bool found, void *param)</td></tr>
<tr class="memdesc:gaf83cd7be39b6efef38709edb06300c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the application of the result of searching for a remote A2DP entity (sourse or sink)  <a href="#gaf83cd7be39b6efef38709edb06300c33">More...</a><br /></td></tr>
<tr class="separator:gaf83cd7be39b6efef38709edb06300c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae663c35c177fba748f5f86c6ea801b8f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gae663c35c177fba748f5f86c6ea801b8f">bt_a2dp_mgr_callback_fp</a>) (bt_a2dp_mgr_t *mgr, bt_byte evt, bt_a2dp_event_t *evt_param, void *callback_param)</td></tr>
<tr class="memdesc:gae663c35c177fba748f5f86c6ea801b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A2DP application callback.  <a href="#gae663c35c177fba748f5f86c6ea801b8f">More...</a><br /></td></tr>
<tr class="separator:gae663c35c177fba748f5f86c6ea801b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6cb7a99f3f0b5be9cfa4189bd69b70ff"><td class="memItemLeft" align="right" valign="top">bt_a2dp_mgr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga6cb7a99f3f0b5be9cfa4189bd69b70ff">bt_a2dp_get_mgr</a> (void)</td></tr>
<tr class="memdesc:ga6cb7a99f3f0b5be9cfa4189bd69b70ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an instance of the A2DP manager.  <a href="#ga6cb7a99f3f0b5be9cfa4189bd69b70ff">More...</a><br /></td></tr>
<tr class="separator:ga6cb7a99f3f0b5be9cfa4189bd69b70ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga139524ac4af24814dc117a7650ee764f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga139524ac4af24814dc117a7650ee764f">bt_a2dp_init</a> (void)</td></tr>
<tr class="memdesc:ga139524ac4af24814dc117a7650ee764f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the A2DP layer.  <a href="#ga139524ac4af24814dc117a7650ee764f">More...</a><br /></td></tr>
<tr class="separator:ga139524ac4af24814dc117a7650ee764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae184ae7ff523a3fb0557b324a6a25f42"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gae184ae7ff523a3fb0557b324a6a25f42">bt_a2dp_start</a> (bt_a2dp_mgr_t *mgr)</td></tr>
<tr class="memdesc:gae184ae7ff523a3fb0557b324a6a25f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the A2DP layer.  <a href="#gae184ae7ff523a3fb0557b324a6a25f42">More...</a><br /></td></tr>
<tr class="separator:gae184ae7ff523a3fb0557b324a6a25f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85b20ac54765375b53f76325937c126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gac85b20ac54765375b53f76325937c126">bt_a2dp_register_callback</a> (bt_a2dp_mgr_t *mgr, <a class="el" href="group__a2dp.html#gae663c35c177fba748f5f86c6ea801b8f">bt_a2dp_mgr_callback_fp</a> callback, void *callback_param)</td></tr>
<tr class="memdesc:gac85b20ac54765375b53f76325937c126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a A2DP application callback.  <a href="#gac85b20ac54765375b53f76325937c126">More...</a><br /></td></tr>
<tr class="separator:gac85b20ac54765375b53f76325937c126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a19ef7a50b8a773b33a408d566d08f"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga69a19ef7a50b8a773b33a408d566d08f">bt_a2dp_open_and_start_stream</a> (bt_a2dp_mgr_t *mgr, bt_byte strm_handle, bt_bdaddr_t *remote_addr, bt_byte seid_int, bt_byte seid_acp, const <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *caps)</td></tr>
<tr class="memdesc:ga69a19ef7a50b8a773b33a408d566d08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open &amp; start a stream.  <a href="#ga69a19ef7a50b8a773b33a408d566d08f">More...</a><br /></td></tr>
<tr class="separator:ga69a19ef7a50b8a773b33a408d566d08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb544c351fa0f4352baf4bd1506b893"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga3bb544c351fa0f4352baf4bd1506b893">bt_a2dp_find_source</a> (bt_bdaddr_t *deviceAddress, <a class="el" href="group__a2dp.html#gaf83cd7be39b6efef38709edb06300c33">bt_a2dp_find_server_callback_fp</a> callback, bt_sdp_client_callback_fp client_callback, void *callback_param)</td></tr>
<tr class="memdesc:ga3bb544c351fa0f4352baf4bd1506b893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find source.  <a href="#ga3bb544c351fa0f4352baf4bd1506b893">More...</a><br /></td></tr>
<tr class="separator:ga3bb544c351fa0f4352baf4bd1506b893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb588e20fd7bcf48c07223b35955e516"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gafb588e20fd7bcf48c07223b35955e516">bt_a2dp_find_sink</a> (bt_bdaddr_t *deviceAddress, <a class="el" href="group__a2dp.html#gaf83cd7be39b6efef38709edb06300c33">bt_a2dp_find_server_callback_fp</a> callback, bt_sdp_client_callback_fp client_callback, void *callback_param)</td></tr>
<tr class="memdesc:gafb588e20fd7bcf48c07223b35955e516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find sink.  <a href="#gafb588e20fd7bcf48c07223b35955e516">More...</a><br /></td></tr>
<tr class="separator:gafb588e20fd7bcf48c07223b35955e516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a2d71e2023013f27899ddeefa77c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gab2a2d71e2023013f27899ddeefa77c40">bt_a2dp_register_mpeg_codec</a> (bt_a2dp_mgr_t *mgr)</td></tr>
<tr class="memdesc:gab2a2d71e2023013f27899ddeefa77c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register default MPEG codec.  <a href="#gab2a2d71e2023013f27899ddeefa77c40">More...</a><br /></td></tr>
<tr class="separator:gab2a2d71e2023013f27899ddeefa77c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66951e65e952cda647a590927e048d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga66951e65e952cda647a590927e048d61">bt_a2dp_register_aac_codec</a> (bt_a2dp_mgr_t *mgr)</td></tr>
<tr class="memdesc:ga66951e65e952cda647a590927e048d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register default AAC codec.  <a href="#ga66951e65e952cda647a590927e048d61">More...</a><br /></td></tr>
<tr class="separator:ga66951e65e952cda647a590927e048d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Source features</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp07cb56a5d28e2775e23ea8a81b033909"></a>The following is a list of features a source can support. The supported features are specified in the corresponding SDP service record and can be retrieved with <a class="el" href="group__a2dp.html#ga3bb544c351fa0f4352baf4bd1506b893" title="Find source. ">bt_a2dp_find_source</a>. </p>
</td></tr>
<tr class="memitem:ga9c34eb381cd6538eda2f281ac850dd63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c34eb381cd6538eda2f281ac850dd63"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga9c34eb381cd6538eda2f281ac850dd63">A2DP_SOURCE_FEATURE_PLAYER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga9c34eb381cd6538eda2f281ac850dd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Player. <br /></td></tr>
<tr class="separator:ga9c34eb381cd6538eda2f281ac850dd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7979c5c3d98c75297d64d8a07e9916"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c7979c5c3d98c75297d64d8a07e9916"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga8c7979c5c3d98c75297d64d8a07e9916">A2DP_SOURCE_FEATURE_MICROPHONE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga8c7979c5c3d98c75297d64d8a07e9916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mic. <br /></td></tr>
<tr class="separator:ga8c7979c5c3d98c75297d64d8a07e9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5232e6369ec46a673f514c454fe46b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5232e6369ec46a673f514c454fe46b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa5232e6369ec46a673f514c454fe46b0">A2DP_SOURCE_FEATURE_TUNER</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaa5232e6369ec46a673f514c454fe46b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuner. <br /></td></tr>
<tr class="separator:gaa5232e6369ec46a673f514c454fe46b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97936ef1e5970c568ba9d4667916fb3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97936ef1e5970c568ba9d4667916fb3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga97936ef1e5970c568ba9d4667916fb3f">A2DP_SOURCE_FEATURE_MIXER</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga97936ef1e5970c568ba9d4667916fb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixer. <br /></td></tr>
<tr class="separator:ga97936ef1e5970c568ba9d4667916fb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sink features</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2446d04485195f71287eaa842a3bb184"></a>The following is a list of features a sink can support. The supported features are specified in the corresponding SDP service record and can be retrieved with <a class="el" href="group__a2dp.html#gafb588e20fd7bcf48c07223b35955e516" title="Find sink. ">bt_a2dp_find_sink</a>. </p>
</td></tr>
<tr class="memitem:ga844206eb4346a77b28f0c03866d80279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga844206eb4346a77b28f0c03866d80279"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga844206eb4346a77b28f0c03866d80279">A2DP_SINK_FEATURE_HEADPHONE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga844206eb4346a77b28f0c03866d80279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Headphone. <br /></td></tr>
<tr class="separator:ga844206eb4346a77b28f0c03866d80279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24386031701e3fbcdc66e24ec9e02876"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24386031701e3fbcdc66e24ec9e02876"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga24386031701e3fbcdc66e24ec9e02876">A2DP_SINK_FEATURE_SPEAKER</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga24386031701e3fbcdc66e24ec9e02876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speaker. <br /></td></tr>
<tr class="separator:ga24386031701e3fbcdc66e24ec9e02876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0a8f9d13ef4a119526eaab43cd44c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d0a8f9d13ef4a119526eaab43cd44c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga8d0a8f9d13ef4a119526eaab43cd44c7">A2DP_SINK_FEATURE_RECORDER</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga8d0a8f9d13ef4a119526eaab43cd44c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recorder. <br /></td></tr>
<tr class="separator:ga8d0a8f9d13ef4a119526eaab43cd44c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34fcf3bf73a5cd91e7b472f9d768201c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34fcf3bf73a5cd91e7b472f9d768201c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga34fcf3bf73a5cd91e7b472f9d768201c">A2DP_SINK_FEATURE_AMPLIFIER</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga34fcf3bf73a5cd91e7b472f9d768201c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplifier. <br /></td></tr>
<tr class="separator:ga34fcf3bf73a5cd91e7b472f9d768201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Events</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp87f9f735a1d36793ceaecd4e47124b63"></a>The following is a list of events A2DP layer generates and can report to the upper layer when it completes executing an operation initiated by either local or remote device. </p>
</td></tr>
<tr class="memitem:ga03bd271140e1ff03e3890c50b59c90eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03bd271140e1ff03e3890c50b59c90eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga03bd271140e1ff03e3890c50b59c90eb">A2DP_EVT_CTRL_CHANNEL_CONNECTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga487bc0f44a77b71894465a0e86af8e2e">AVDTP_EVT_CTRL_CHANNEL_CONNECTED</a></td></tr>
<tr class="memdesc:ga03bd271140e1ff03e3890c50b59c90eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a control channel between two AVDTP entities has been established. <br /></td></tr>
<tr class="separator:ga03bd271140e1ff03e3890c50b59c90eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95cc08bd8dbfefbd3bd6688b4769379c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95cc08bd8dbfefbd3bd6688b4769379c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga95cc08bd8dbfefbd3bd6688b4769379c">A2DP_EVT_CTRL_CHANNEL_DISCONNECTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac2d7a0213d056ec3dbf7f57a93e2b528">AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED</a></td></tr>
<tr class="memdesc:ga95cc08bd8dbfefbd3bd6688b4769379c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a control channel between two AVDTP entities has been terminated. <br /></td></tr>
<tr class="separator:ga95cc08bd8dbfefbd3bd6688b4769379c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1094c82b37f2d3d8edf0f5181f81d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b1094c82b37f2d3d8edf0f5181f81d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga4b1094c82b37f2d3d8edf0f5181f81d6">A2DP_EVT_CTRL_CONNECTION_FAILED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga63bcaad109a3f543f2967a6b54323715">AVDTP_EVT_CTRL_CONNECTION_FAILED</a></td></tr>
<tr class="memdesc:ga4b1094c82b37f2d3d8edf0f5181f81d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device failed to create a control channel between two AVDTP entities. <br /></td></tr>
<tr class="separator:ga4b1094c82b37f2d3d8edf0f5181f81d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8f29824b91216035e6ca130f6bfbf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec8f29824b91216035e6ca130f6bfbf1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaec8f29824b91216035e6ca130f6bfbf1">A2DP_EVT_DISCOVER_SEP_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga97cacb1c59c0f81b6e2d99e115663620">AVDTP_EVT_DISCOVER_COMPLETED</a></td></tr>
<tr class="memdesc:gaec8f29824b91216035e6ca130f6bfbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "discover" request. <br /></td></tr>
<tr class="separator:gaec8f29824b91216035e6ca130f6bfbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec48559cc431a04530e1c5d436d06e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec48559cc431a04530e1c5d436d06e9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaec48559cc431a04530e1c5d436d06e9a">A2DP_EVT_GET_SEP_CAPABILITIES_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaa0d9212f94534842dcbb45cd31165bb2">AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED</a></td></tr>
<tr class="memdesc:gaec48559cc431a04530e1c5d436d06e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "get SEP capabilities" request. <br /></td></tr>
<tr class="separator:gaec48559cc431a04530e1c5d436d06e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8989b761b2ef1275432c631f738889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e8989b761b2ef1275432c631f738889"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga1e8989b761b2ef1275432c631f738889">A2DP_EVT_SET_STREAM_CONFIGURATION_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac5746451b5464681c2647b3759fede77">AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED</a></td></tr>
<tr class="memdesc:ga1e8989b761b2ef1275432c631f738889"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "set stream configuration" request. <br /></td></tr>
<tr class="separator:ga1e8989b761b2ef1275432c631f738889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b49328e830ba821b5c6c76c2aea85b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b49328e830ba821b5c6c76c2aea85b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga3b49328e830ba821b5c6c76c2aea85b4">A2DP_EVT_GET_STREAM_CONFIGURATION_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga6b70889dd53eef85eb7f9544e96defe8">AVDTP_EVT_GET_STREAM_CONFIGURATION_COMPLETED</a></td></tr>
<tr class="memdesc:ga3b49328e830ba821b5c6c76c2aea85b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "get stream configuration" request. <br /></td></tr>
<tr class="separator:ga3b49328e830ba821b5c6c76c2aea85b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea3a2dff49ad311b780421f7f4b3ea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ea3a2dff49ad311b780421f7f4b3ea9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga2ea3a2dff49ad311b780421f7f4b3ea9">A2DP_EVT_RECONFIGURE_STREAM_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gab5c6c2394d3fc63950125d13336ab888">AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED</a></td></tr>
<tr class="memdesc:ga2ea3a2dff49ad311b780421f7f4b3ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "change stream configuration" request. <br /></td></tr>
<tr class="separator:ga2ea3a2dff49ad311b780421f7f4b3ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88c97c302b804916575e53189dfe185"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa88c97c302b804916575e53189dfe185"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa88c97c302b804916575e53189dfe185">A2DP_EVT_OPEN_STREAM_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga4ad709ebeea699c1528781dea4dbd828">AVDTP_EVT_OPEN_STREAM_COMPLETED</a></td></tr>
<tr class="memdesc:gaa88c97c302b804916575e53189dfe185"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "open stream" request. <br /></td></tr>
<tr class="separator:gaa88c97c302b804916575e53189dfe185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7f85cd828f6fddc2b774eb29802d2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f7f85cd828f6fddc2b774eb29802d2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga8f7f85cd828f6fddc2b774eb29802d2d">A2DP_EVT_START_STREAM_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gad43101d6b56f2a60a1e4b9fa7af5e484">AVDTP_EVT_START_STREAM_COMPLETED</a></td></tr>
<tr class="memdesc:ga8f7f85cd828f6fddc2b774eb29802d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "start stream" request. <br /></td></tr>
<tr class="separator:ga8f7f85cd828f6fddc2b774eb29802d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167f3973720fded955b8963095ed42ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga167f3973720fded955b8963095ed42ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga167f3973720fded955b8963095ed42ba">A2DP_EVT_CLOSE_STREAM_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga29531d2b1322305df3a053e9971a55d3">AVDTP_EVT_CLOSE_STREAM_COMPLETED</a></td></tr>
<tr class="memdesc:ga167f3973720fded955b8963095ed42ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "close stream" request. <br /></td></tr>
<tr class="separator:ga167f3973720fded955b8963095ed42ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1ea6fc2b41c1532f09769d745f0b19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a1ea6fc2b41c1532f09769d745f0b19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga1a1ea6fc2b41c1532f09769d745f0b19">A2DP_EVT_SUSPEND_STREAM_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga754b6c1ad22364cbd538922a148490f3">AVDTP_EVT_SUSPEND_STREAM_COMPLETED</a></td></tr>
<tr class="memdesc:ga1a1ea6fc2b41c1532f09769d745f0b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "suspend stream" request. <br /></td></tr>
<tr class="separator:ga1a1ea6fc2b41c1532f09769d745f0b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7957e42814217c672737a4c01b0e797d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7957e42814217c672737a4c01b0e797d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga7957e42814217c672737a4c01b0e797d">A2DP_EVT_STREAM_SECURITY_CONTROL_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga275faa00a9661ac03a4b879f3155567b">AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED</a></td></tr>
<tr class="memdesc:ga7957e42814217c672737a4c01b0e797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "exchange content protection control data" request. <br /></td></tr>
<tr class="separator:ga7957e42814217c672737a4c01b0e797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02169d4358bd3424dfc5b1f51e66d813"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga02169d4358bd3424dfc5b1f51e66d813"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga02169d4358bd3424dfc5b1f51e66d813">A2DP_EVT_ABORT_STREAM_COMPLETED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac924f50164e6d7fd4478a5dc5d10ba71">AVDTP_EVT_ABORT_STREAM_COMPLETED</a></td></tr>
<tr class="memdesc:ga02169d4358bd3424dfc5b1f51e66d813"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a response (either positive or negative) to a "abort stream" request. <br /></td></tr>
<tr class="separator:ga02169d4358bd3424dfc5b1f51e66d813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1072dca352ca331ba9d61bf9ca67e4b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1072dca352ca331ba9d61bf9ca67e4b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga1072dca352ca331ba9d61bf9ca67e4b4">A2DP_EVT_SEP_INFO_RECEIVED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga984ef1c88a76945564e7ecea7d13657b">AVDTP_EVT_SEP_INFO_RECEIVED</a></td></tr>
<tr class="memdesc:ga1072dca352ca331ba9d61bf9ca67e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated for each SEP contained in a positive response to a "discover" request. <br /></td></tr>
<tr class="separator:ga1072dca352ca331ba9d61bf9ca67e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f9a660dce6233cdc96eb0695510392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05f9a660dce6233cdc96eb0695510392"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga05f9a660dce6233cdc96eb0695510392">A2DP_EVT_SEP_CAPABILITIES_RECEIVED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga7c3c334e2d7f5e1c877379243200767d">AVDTP_EVT_SEP_CAPABILITIES_RECEIVED</a></td></tr>
<tr class="memdesc:ga05f9a660dce6233cdc96eb0695510392"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a positive response to a "get SEP capabilities" request. <br /></td></tr>
<tr class="separator:ga05f9a660dce6233cdc96eb0695510392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2223078091e499f5ef1a72fdd0875f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade2223078091e499f5ef1a72fdd0875f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gade2223078091e499f5ef1a72fdd0875f">A2DP_EVT_STREAM_CONFIGURATION_RECEIVED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga37b941fe0c3d0a5064f65c1aa9e97be3">AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED</a></td></tr>
<tr class="memdesc:gade2223078091e499f5ef1a72fdd0875f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a positive response to a "get stream configuration" request. <br /></td></tr>
<tr class="separator:gade2223078091e499f5ef1a72fdd0875f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8774fdb6451eaf33a9ca6efc6565fbc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8774fdb6451eaf33a9ca6efc6565fbc1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga8774fdb6451eaf33a9ca6efc6565fbc1">A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaa8bd4fadade17f21abd71c7db4fff1d9">AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED</a></td></tr>
<tr class="memdesc:ga8774fdb6451eaf33a9ca6efc6565fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "set stream configuration" request. <br /></td></tr>
<tr class="separator:ga8774fdb6451eaf33a9ca6efc6565fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1aea058a66edc5b9e359a1edd90dc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f1aea058a66edc5b9e359a1edd90dc6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga2f1aea058a66edc5b9e359a1edd90dc6">A2DP_EVT_OPEN_STREAM_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaeb9fbffe93347d536c2e3d11a8b02fb3">AVDTP_EVT_OPEN_STREAM_REQUESTED</a></td></tr>
<tr class="memdesc:ga2f1aea058a66edc5b9e359a1edd90dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "open stream" request. <br /></td></tr>
<tr class="separator:ga2f1aea058a66edc5b9e359a1edd90dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172c0a9f7f037a5e3a9d43c433cc47e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga172c0a9f7f037a5e3a9d43c433cc47e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga172c0a9f7f037a5e3a9d43c433cc47e7">A2DP_EVT_START_STREAM_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga12d8f1ef04ce43f994dc05bc833f2603">AVDTP_EVT_START_STREAM_REQUESTED</a></td></tr>
<tr class="memdesc:ga172c0a9f7f037a5e3a9d43c433cc47e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "start stream" request. <br /></td></tr>
<tr class="separator:ga172c0a9f7f037a5e3a9d43c433cc47e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e8b5c35f39bd54947ffe232a1bb240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5e8b5c35f39bd54947ffe232a1bb240"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gaa5e8b5c35f39bd54947ffe232a1bb240">A2DP_EVT_CLOSE_STREAM_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga691b824e56e1b955c12df4580b75417f">AVDTP_EVT_CLOSE_STREAM_REQUESTED</a></td></tr>
<tr class="memdesc:gaa5e8b5c35f39bd54947ffe232a1bb240"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "close stream" request. <br /></td></tr>
<tr class="separator:gaa5e8b5c35f39bd54947ffe232a1bb240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f4962cbefb6a09b62b51c3826afc4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1f4962cbefb6a09b62b51c3826afc4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gae1f4962cbefb6a09b62b51c3826afc4f">A2DP_EVT_SUSPEND_STREAM_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaf15b9087ffa5bd436754de42bde45193">AVDTP_EVT_SUSPEND_STREAM_REQUESTED</a></td></tr>
<tr class="memdesc:gae1f4962cbefb6a09b62b51c3826afc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "suspend stream" request. <br /></td></tr>
<tr class="separator:gae1f4962cbefb6a09b62b51c3826afc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67b9c9d940ef5f48624c58dd62cc26b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad67b9c9d940ef5f48624c58dd62cc26b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gad67b9c9d940ef5f48624c58dd62cc26b">A2DP_EVT_ABORT_STREAM_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga791f338f65f1be9a4a587774fe9b1ed1">AVDTP_EVT_ABORT_STREAM_REQUESTED</a></td></tr>
<tr class="memdesc:gad67b9c9d940ef5f48624c58dd62cc26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "abort stream" request. <br /></td></tr>
<tr class="separator:gad67b9c9d940ef5f48624c58dd62cc26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7725c12ec25d6177de9ac3dd441c317"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac7725c12ec25d6177de9ac3dd441c317"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gac7725c12ec25d6177de9ac3dd441c317">A2DP_EVT_RECONFIGURE_STREAM_REQUESTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga056aed39ca4a8766cde542ffb6b4a531">AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED</a></td></tr>
<tr class="memdesc:gac7725c12ec25d6177de9ac3dd441c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received "change stream configuration" request. <br /></td></tr>
<tr class="separator:gac7725c12ec25d6177de9ac3dd441c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5fe0b41500cfebce4ceb40c6b18e69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a5fe0b41500cfebce4ceb40c6b18e69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga7a5fe0b41500cfebce4ceb40c6b18e69">A2DP_EVT_MEDIA_PACKET_RECEIVED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaae4a6c492fc1c378cfc88b50c74c5d93">AVDTP_EVT_MEDIA_PACKET_RECEIVED</a></td></tr>
<tr class="memdesc:ga7a5fe0b41500cfebce4ceb40c6b18e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device received a media packet. <br /></td></tr>
<tr class="separator:ga7a5fe0b41500cfebce4ceb40c6b18e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dee6ce4b9d8b6e87d66bcbecc7b5a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga96dee6ce4b9d8b6e87d66bcbecc7b5a5">A2DP_EVT_STREAM_CONFIGURED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga47c1534b561220d8bab57826d58124a6">AVDTP_EVT_STREAM_CONFIGURED</a></td></tr>
<tr class="memdesc:ga96dee6ce4b9d8b6e87d66bcbecc7b5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully configured a stream.  <a href="#ga96dee6ce4b9d8b6e87d66bcbecc7b5a5">More...</a><br /></td></tr>
<tr class="separator:ga96dee6ce4b9d8b6e87d66bcbecc7b5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbdafa5027491f231d34e62db072b2d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gadbdafa5027491f231d34e62db072b2d3">A2DP_EVT_STREAM_RECONFIGURED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga7c09597f17888f6b329e537d2daff714">AVDTP_EVT_STREAM_RECONFIGURED</a></td></tr>
<tr class="memdesc:gadbdafa5027491f231d34e62db072b2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully reconfigured a stream.  <a href="#gadbdafa5027491f231d34e62db072b2d3">More...</a><br /></td></tr>
<tr class="separator:gadbdafa5027491f231d34e62db072b2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa185b50b508a90a3fb409ad46dc3d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gacfa185b50b508a90a3fb409ad46dc3d9">A2DP_EVT_STREAM_OPENED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga5b587f362b71e3ee6a3c697d1d810dfb">AVDTP_EVT_STREAM_OPENED</a></td></tr>
<tr class="memdesc:gacfa185b50b508a90a3fb409ad46dc3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully opened a stream.  <a href="#gacfa185b50b508a90a3fb409ad46dc3d9">More...</a><br /></td></tr>
<tr class="separator:gacfa185b50b508a90a3fb409ad46dc3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb5f5a08355bab7b2e67717c2d0cb52c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gadb5f5a08355bab7b2e67717c2d0cb52c">A2DP_EVT_STREAM_STARTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga30a1880fcf2843851bfdcc1c1ce26fe4">AVDTP_EVT_STREAM_STARTED</a></td></tr>
<tr class="memdesc:gadb5f5a08355bab7b2e67717c2d0cb52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully started a stream.  <a href="#gadb5f5a08355bab7b2e67717c2d0cb52c">More...</a><br /></td></tr>
<tr class="separator:gadb5f5a08355bab7b2e67717c2d0cb52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41599915de0199967c81708e257ad4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#gab41599915de0199967c81708e257ad4e">A2DP_EVT_STREAM_CLOSED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaaaf4589b4e06f8da64956618b13c6d90">AVDTP_EVT_STREAM_CLOSED</a></td></tr>
<tr class="memdesc:gab41599915de0199967c81708e257ad4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully closed a stream.  <a href="#gab41599915de0199967c81708e257ad4e">More...</a><br /></td></tr>
<tr class="separator:gab41599915de0199967c81708e257ad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b58fbff51ed39a7e63e87c7e1a9e721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga7b58fbff51ed39a7e63e87c7e1a9e721">A2DP_EVT_STREAM_SUSPENDED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga5efd33cc271c43335507a3c6875461b4">AVDTP_EVT_STREAM_SUSPENDED</a></td></tr>
<tr class="memdesc:ga7b58fbff51ed39a7e63e87c7e1a9e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully suspended a stream.  <a href="#ga7b58fbff51ed39a7e63e87c7e1a9e721">More...</a><br /></td></tr>
<tr class="separator:ga7b58fbff51ed39a7e63e87c7e1a9e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d671ddb127a60ca50df80cbdad01ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga52d671ddb127a60ca50df80cbdad01ba">A2DP_EVT_STREAM_ABORTED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac111c73e90b207bae2346c072960bcef">AVDTP_EVT_STREAM_ABORTED</a></td></tr>
<tr class="memdesc:ga52d671ddb127a60ca50df80cbdad01ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device has successfully aborted a stream.  <a href="#ga52d671ddb127a60ca50df80cbdad01ba">More...</a><br /></td></tr>
<tr class="separator:ga52d671ddb127a60ca50df80cbdad01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f5dd40c5a510f455dd56a0be75c56c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f5dd40c5a510f455dd56a0be75c56c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga2f5dd40c5a510f455dd56a0be75c56c2">A2DP_EVT_MEDIA_PACKET_SENT</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga7073934f0aeaa7da349108c214ac9748">AVDTP_EVT_MEDIA_PACKET_SENT</a></td></tr>
<tr class="memdesc:ga2f5dd40c5a510f455dd56a0be75c56c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device sent a media packet. <br /></td></tr>
<tr class="separator:ga2f5dd40c5a510f455dd56a0be75c56c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56397904a0dfeb1a1fc3d212e544e9c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56397904a0dfeb1a1fc3d212e544e9c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga56397904a0dfeb1a1fc3d212e544e9c0">A2DP_EVT_MEDIA_PACKET_SEND_FAILED</a>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac2d6753d097d685b19b733d93062b7cc">AVDTP_EVT_MEDIA_PACKET_SEND_FAILED</a></td></tr>
<tr class="memdesc:ga56397904a0dfeb1a1fc3d212e544e9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device failed to send a media packet. <br /></td></tr>
<tr class="separator:ga56397904a0dfeb1a1fc3d212e544e9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d69b2aed0f51b8124d8cbb566c5662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69d69b2aed0f51b8124d8cbb566c5662"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__a2dp.html#ga69d69b2aed0f51b8124d8cbb566c5662">A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED</a>&#160;&#160;&#160;(AVDTP_EVT_LAST + 1)</td></tr>
<tr class="memdesc:ga69d69b2aed0f51b8124d8cbb566c5662"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a local device completed "open and start" request. <br /></td></tr>
<tr class="separator:ga69d69b2aed0f51b8124d8cbb566c5662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Advanced Audio Distribution Profile (A2DP) defines the protocols and procedures that realize distribution of audio content of high-quality in mono or stereo on ACL channels. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga52d671ddb127a60ca50df80cbdad01ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_ABORTED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac111c73e90b207bae2346c072960bcef">AVDTP_EVT_STREAM_ABORTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully aborted a stream. </p>
<p>This event follows the A2DP_EVT_ABORT_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream abortion was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gab41599915de0199967c81708e257ad4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_CLOSED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaaaf4589b4e06f8da64956618b13c6d90">AVDTP_EVT_STREAM_CLOSED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully closed a stream. </p>
<p>This event follows the A2DP_EVT_CLOSE_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream closing was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga96dee6ce4b9d8b6e87d66bcbecc7b5a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_CONFIGURED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga47c1534b561220d8bab57826d58124a6">AVDTP_EVT_STREAM_CONFIGURED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully configured a stream. </p>
<p>This event follows the A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED if the upper layer has accepted it. This event is not generated if stream configuration was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gacfa185b50b508a90a3fb409ad46dc3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_OPENED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga5b587f362b71e3ee6a3c697d1d810dfb">AVDTP_EVT_STREAM_OPENED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully opened a stream. </p>
<p>This event follows the A2DP_EVT_OPEN_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream opening was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gadbdafa5027491f231d34e62db072b2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_RECONFIGURED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga7c09597f17888f6b329e537d2daff714">AVDTP_EVT_STREAM_RECONFIGURED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully reconfigured a stream. </p>
<p>This event follows the A2DP_EVT_RECONFIGURE_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream reconfiguration was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gadb5f5a08355bab7b2e67717c2d0cb52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_STARTED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga30a1880fcf2843851bfdcc1c1ce26fe4">AVDTP_EVT_STREAM_STARTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully started a stream. </p>
<p>This event follows the A2DP_EVT_START_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream starting was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="ga7b58fbff51ed39a7e63e87c7e1a9e721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define A2DP_EVT_STREAM_SUSPENDED&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga5efd33cc271c43335507a3c6875461b4">AVDTP_EVT_STREAM_SUSPENDED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a local device has successfully suspended a stream. </p>
<p>This event follows the A2DP_EVT_SUSPEND_STREAM_REQUESTED if the upper layer has accepted it. This event is not generated if stream suspension was initiated by the local device. </p>

</div>
</div>
<a class="anchor" id="gad305d643b5e8fa8dd3df0e087b0dcc80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_abort_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga3b2882c4e47b122d8f26fd505bbf5f8a">bt_avdtp_abort_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a stream. </p>
<p>This function tries to suspend a stream by sending a request to the remote party. The stream can be in any state state except AVDTP_STREAM_STATE_IDLE. As a result of this operation the A2DP_EVT_ABORT_STREAM_COMPLETED event will be generated. This operation cannot be rejected. The <code>evt_param.abort_stream_requested.err_code</code> is always == AVDTP_ERROR_SUCCESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad21b8afb1fad71e22f75d199bd992944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_add_media_rx_buffer</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaae73bd76bdea0c11165e3ababce488e4">bt_avdtp_add_media_rx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a media packet buffer to a receive queue. </p>
<p>The consumer of A2DP is responsible for allocating and supplying A2DP with buffers used to store received packets. A2DP itself only has a queue for storing pointers to buffers supplied by the consumer. When a packet comes in A2DP finds the first buffer large enough to hold the received packet, copies the packet to the buffer and generates a A2DP_EVT_MEDIA_PACKET_RECEIVED event. The consumer then has to process the data in the buffer and return it back to the queue. If there is no buffers in the queue or none of the buffers is large enough the received packets is dropped. Each buffer has a field (data_len) that holds the length of the received buffer. This field is never 0 if the buffer contains a packet. If a channel closed regardless of what has caused that and there are still buffers in the queue A2DP generates a A2DP_EVT_MEDIA_PACKET_RECEIVED event for each buffer and sets the data_len to 0. This is to inform the A2DP consumer that the buffer has not been used and can be, for example, deallocated. This function adds a buffer to the receive queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4617776126236643c24411cdbd1808af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_add_media_tx_buffer</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga563a397fc0ec80d6dcd7f93c5ea4c9d8">bt_avdtp_add_media_tx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a media packet buffer to a send queue. </p>
<p>When the consumer of A2DP wants to send a packet to a remote device it calls this function. The function adds the packet to a queue and tells A2DP that it has something to send. The packet will be send as soon as the stream goes to A2DP_STREAM_STATE_STREAMING state. When the packet has been successfully sent a A2DP_EVT_MEDIA_PACKET_SENT is generated. Otherwise a A2DP_EVT_MEDIA_PACKET_SEND_FAILED is generated. Regardless of the event generated the consumer can re-use the buffer as A2DP has removed it from the queue and gave up control over it. As in the case of received buffers, if a channel closed regardless of what has caused that and there are still buffers in the queue A2DP generates a A2DP_EVT_MEDIA_PACKET_SENT event for each buffer and sets the data_len field to 0. This is to inform the AVDTP consumer that the buffer has not been used and can be, for example, deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5084e7a6d925f30dee5fa66bd2c68400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_cancel_listen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sep_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga5f5030fc428a0d8245d7f725414443ec">bt_avdtp_cancel_listen</a>(mgr-&gt;avdtp_mgr, strm_handle, sep_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel listening for incoming connections. </p>
<p>This function removes a SEP from a list of SEPS which a stream can use for incoming requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">sep_id</td><td>Local SEP ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadf2b248664684a3ebb401855112e79f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_close_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaa183c4355d28d15e938a4a088c7a77fd">bt_avdtp_close_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a stream. </p>
<p>This function tries to close a stream by sending a request to the remote party. The stream has to be in AVDTP_STREAM_STATE_OPEN or AVDTP_STREAM_STATE_STREAMING state. As a result of this operation the A2DP_EVT_CLOSE_STREAM_COMPLETED event will be generated. If the stream has been closed the <code>evt_param.bt_avdtp_evt_close_stream_completed_t.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to close the stream, the <code>evt_param.bt_avdtp_evt_close_stream_completed_t.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa787176a321c0f101abb10e9d7b37bc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_connect</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gadc565b71c9d76e8a3c6c838436605b83">bt_avdtp_connect</a>(mgr-&gt;avdtp_mgr, remote_addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote device. </p>
<p>This function opens a control channel connection to a remote device specified by the <code>remote_addr</code>. If connection cannot be initiated for some reason, for example, there is not enough resources, it returns FALSE and not events are generated. Otherwise the result of an attempt to connect to the remote device is reported via the AVDTP callback. The events generated will either be A2DP_EVT_CTRL_CHANNEL_CONNECTED or A2DP_EVT_CTRL_CHANNEL_CONNECTION_FAILED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if connection establishment has been started. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e9d178b56d8701221d39126157b30b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_connect_ex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">acl_config&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga258c796e3a420d6fc29d10035fe47cd9">bt_avdtp_connect_ex</a>(mgr-&gt;avdtp_mgr, remote_addr, acl_config)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote device. </p>
<p>This function opens a control channel connection to a remote device specified by the <code>remote_addr</code>. If connection cannot be initiated for some reason, for example, there is not enough resources, it returns FALSE and not events are generated. Otherwise the result of an attempt to connect to the remote device is reported via the AVDTP callback. The events generated will either be A2DP_EVT_CTRL_CHANNEL_CONNECTED or A2DP_EVT_CTRL_CHANNEL_CONNECTION_FAILED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">acl_config</td><td>ACL link configuration. This can be a combination of the following values: <ul>
<li>HCI_CONFIG_ENABLE_AUTHENTICATION </li>
<li>HCI_CONFIG_ENABLE_ENCRYPTION </li>
<li>HCI_CONFIG_BECOME_MASTER</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if connection establishment has been started. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad534e9a5d37032540a4934d430bfe92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_create_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gab49d03d6642d60ee5bb8628d1e96a088">bt_avdtp_create_stream</a>(mgr-&gt;avdtp_mgr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream. </p>
<p>This function allocates memory for storing stream's data and assigns a stream handle. The stream handle is used to manipulate the stream - open, close, configure, suspend, abort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>Stream</code> handle if the function succeeds. </li>
<li><code>0</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6d14d1256b380638c015c166056755d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_destroy_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gad90fbc2862c2220022f113512b97e2be">bt_avdtp_destroy_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a stream. </p>
<p>This function frees memory used by the stream. The stream has to exist and be in the "idle" state for this function to succeed. I.e. the stream has to be closed or aborted before this function can be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8391ae990eca2b62adb0b1170f8b7cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_disconnect</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga2d7b41ff858c3930e8280d76dbbed835">bt_avdtp_disconnect</a>(mgr-&gt;avdtp_mgr, remote_addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect from a remote device. </p>
<p>This function closes a control and transport channels on all streams associated with the remote device specified by the <code>remote_addr</code>. As a result of this operation the following events will be generated: </p><ul>
<li>A2DP_EVT_MEDIA_PACKET_RECEIVED: if a stream's receive queue is not empty this event is generated for each buffer with bt_media_packet_t::data_len set to 0 </li>
<li>A2DP_EVT_MEDIA_PACKET_SENT: if a stream's send queue is not empty this event is generated for each buffer with bt_media_packet_t::data_len set to 0 </li>
<li>A2DP_EVT_STREAM_CLOSED: this event is generate if a stream is in "closing" state as a result of a request from the remote device or <a class="el" href="group__a2dp.html#gadf2b248664684a3ebb401855112e79f2" title="Close a stream. ">bt_a2dp_close_stream</a> call before <a class="el" href="group__a2dp.html#ga8391ae990eca2b62adb0b1170f8b7cc1" title="Disconnect from a remote device. ">bt_a2dp_disconnect</a> call. </li>
<li>A2DP_EVT_STREAM_ABORTED: this event is generated if a stream is in "active" state at the time of bt_avdtp_disconnect call.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if disconnection has been started. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5cf58af894cb3667bbc54517418b820b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_discover</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga7d3da0a9fa37246063d5f7c9688f9df4">bt_avdtp_discover</a>(mgr-&gt;avdtp_mgr, remote_addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover SEPs on a remote device. </p>
<p>This function asks the remote device to send a list of all available SEPs. As a result of this operation the following events will be generated: </p><ul>
<li>A2DP_EVT_SEP_INFO_RECEIVED: this event is generated for every SEP received from the remote device. the <code>evt_param.sep_info_received</code> contains SEP information. </li>
<li>A2DP_EVT_DISCOVER_COMPLETED: this event is generated after the last A2DP_EVT_SEP_INFO_RECEIVED if the remote accepted the request and the <code>evt_param.discover_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.discover_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if discover request has been sent. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga66343282e7c6d52d7bd604e29ab18cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_find_codec</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">codec_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga9663f6647cd82a7afa2fbc0f40df9571">bt_avdtp_find_codec</a>(mgr-&gt;avdtp_mgr, codec_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a codec. </p>
<p>A2DP in theory can support any type of codec. Each codec uses its own format for exchanging capabilities and configuration information. In order to make our implementation do not care about these formats we use a simple way of telling AVDTP how to parse and serialize codec's configuration. The consumer of A2DP has to register a callback function (one per codec type) for each codec it wishes to support. That callback has to perform two function. The first one is to read the configuration received from the remote device and store it in a structure defined by the consumer. The second one is to serialize the data from a structure to a format (in case of standard A2DP codecs the format is defined in A2DP specification, vendor specific codecs can define their own formats) suitable for sending as a part of a AVDTP request. This function returns a pointer to a structure that holds a pointer to a codec's callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">codec_type</td><td>Codec type. The codec_type can be one of the following values: <ul>
<li>AVDTP_CODEC_TYPE_SBC: SBC </li>
<li>AVDTP_CODEC_TYPE_MPEG1_2_AUDIO: MPEG-1,2 (used in MP3 files) </li>
<li>AVDTP_CODEC_TYPE_MPEG2_4_AAC: MPEG-2,4 AAC (used in Apple products) </li>
<li>AVDTP_CODEC_TYPE_ATRAC: ATRAC (used in Sony products) </li>
<li>AVDTP_CODEC_TYPE_NON_A2DP: Non-A2DP Codec</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails if a callback for a codec type specified in the <code>codec</code> parameter </li>
<li>has not been previously registered with <a class="el" href="group__avdtp.html#ga35b9313048cf22068276f9dc5505debb" title="Register a codec. ">bt_avdtp_register_codec</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1bf6975403e1593baa0c1c9da69fcf08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_all_capabilities</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seid_acp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga92da4c6c289f244cc2d797dd20a4ce93">bt_avdtp_get_all_capabilities</a>(mgr-&gt;avdtp_mgr, remote_addr, seid_acp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get remote SEP capabilities. </p>
<p>This function asks the remote device to send capabilities of a SEP specified by the <code>seid_acp</code>. As a result of this operation the following events will be generated: </p><ul>
<li>A2DP_EVT_SEP_CAPABILITIES_RECEIVED: this event is generated if the remote device accepted the request. the <code>evt_param.sep_capabilities_received</code> contains SEP capabilities. </li>
<li>A2DP_EVT_GET_SEP_CAPABILITIES_COMPLETED: this event is generated right after A2DP_EVT_SEP_CAPABILITIES_RECEIVED if the remote accepted the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">seid_acp</td><td>The ID of a remote SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if discover request has been sent. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabfe176f0d104300280b99f98f0de3762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_capabilities</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seid_acp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gadac43ab93b9bbfc44adb11d00432cac8">bt_avdtp_get_capabilities</a>(mgr-&gt;avdtp_mgr, remote_addr, seid_acp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get remote SEP capabilities. </p>
<p>This function asks the remote device to send capabilities of a SEP specified by the <code>seid_acp</code>. As a result of this operation the following events will be generated: </p><ul>
<li>A2DP_EVT_SEP_CAPABILITIES_RECEIVED: this event is generated if the remote device accepted the request. the <code>evt_param.sep_capabilities_received</code> contains SEP capabilities. </li>
<li>A2DP_EVT_GET_SEP_CAPABILITIES_COMPLETED: this event is generated right after A2DP_EVT_SEP_CAPABILITIES_RECEIVED if the remote accepted the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == AVDTP_ERROR_SUCCESS. if the remote rejected the request the <code>evt_param.get_sep_capabilities_completed.err_code</code> == the error code sent by the remote.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">seid_acp</td><td>The ID of a remote SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if discover request has been sent. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7649bee07a84e3c0eeda24d72adda8f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_hci_connection</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaeb053fd416a62a4ef9ccc9d591aca6c2">bt_avdtp_get_hci_connection</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get HCI connection for a stream. </p>
<p>This function returns a pointer to a structure that describes an HCI connection a stream is open on. The return value can be used to call various function from the HCI layer. For example, if an app wants to force disconnection from a remote device it can call <a class="el" href="group__hci.html#gac4cb803c0035a1b7c131a6b029a67589" title="Abort connection. ">bt_hci_disconnect</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>Pointer</code> to a structure that describes an HCI connection if the function succeeds. </li>
<li><code>NULL</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist or there is no HCI connection between local and remote devices associated with the stream.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has not been implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga23fb6d8e2a44ab1cc9ab8fbd50de885f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_stream_codec_config</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gade095bf025f9fb35c93613ecf758ce02">bt_avdtp_get_stream_codec_config</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configuration of the codec currently used with the stream. </p>
<p>This function returns a pointer to a structure that contains configuration of the codec currently used with the stream. The structure returned depends on the codec. The dotstack defines structures only for SBC, MPEG-1,2 and MPEG-2,4 AAC codecs: </p><ul>
<li>SBC: <a class="el" href="structbt__a2dp__sbc__config__t.html">bt_a2dp_sbc_config_t</a> (defined in a2dp_sbc_codec.h) </li>
<li>MPEG-1,2: <a class="el" href="structbt__a2dp__mpeg__config__t.html">bt_a2dp_mpeg_config_t</a> (defined in a2dp_mpeg_codec.h) </li>
<li>MPEG-2,4 AAC: <a class="el" href="structbt__a2dp__aac__config__t.html">bt_a2dp_aac_config_t</a> (defined in a2dp_aac_codec.h)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The codec's configuration if strm_handle specifies a valid stream and the stream is in one of the following state: <pre class="fragment">    AVDTP_STREAM_STATE_CONFIGURED
    AVDTP_STREAM_STATE_OPEN
    AVDTP_STREAM_STATE_STREAMING

    \li NULL otherwise.</pre> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad264bf656fbf078e00113546afc21b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_stream_codec_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga450ff68934f53a6c2ddaeb0cca29fab7">bt_avdtp_get_stream_codec_type</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the codec currently used with the stream. </p>
<p>This function returns the type of the codec currently used with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The type of the codec if strm_handle specifies a valid stream and the stream is in one of the following states: <pre class="fragment">      AVDTP_STREAM_STATE_CONFIGURED
      AVDTP_STREAM_STATE_OPEN
      AVDTP_STREAM_STATE_STREAMING

    @arg The result will be one of the following values:

       AVDTP_CODEC_TYPE_SBC:           SBC
       AVDTP_CODEC_TYPE_MPEG1_2_AUDIO: MPEG-1,2 (used in MP3 files)
       AVDTP_CODEC_TYPE_MPEG2_4_AAC:   MPEG-2,4 AAC (used in Apple products)
       AVDTP_CODEC_TYPE_ATRAC:         ATRAC (used in Sony products)
       AVDTP_CODEC_TYPE_NON_A2DP:      Non-A2DP Codec

    @arg 0xFF otherwise.</pre> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0f2c5e4a274efa5d733e4fbee85f3f78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_stream_local_sep_id</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gae3ba4a1f9d3a9d91268cf66aa9afd589">bt_avdtp_get_stream_local_sep_id</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's local SEP ID. </p>
<p>This function returns the ID of the local SEP associated with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The ID of the local SEP if strm_handle specifies a valid stream. </li>
<li>0 otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa0650e870e5bb7cc4bd41e6c0ad22f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_stream_remote_address</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gab67ac3b6a1501e1cba70af33172dfa1a">bt_avdtp_get_stream_remote_address</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's remote BT address. </p>
<p>This function returns the address of the remote device associated with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The address of the remote device if strm_handle specifies a valid stream. </li>
<li>NULL otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9b96c8d3f7d27fce5d7d948fb91ac40e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_stream_remote_sep_id</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaa7135cde7501a2ec46b2921169b68599">bt_avdtp_get_stream_remote_sep_id</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's remote SEP ID. </p>
<p>This function returns the ID of the remote SEP associated with the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The ID of the remote SEP if strm_handle specifies a valid stream. </li>
<li>0 otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab7a92fc8861b1682d6b2cac689a7e703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_get_stream_state</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gaed4fd0933472235f2ffa1594daccde7c">bt_avdtp_get_stream_state</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get local stream state. </p>
<p>This function returns local state of a stream specified by the <code>strm_handle</code>. No request is sent to the remote party.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of the stream. The result will be one of the following values: <ul>
<li>AVDTP_STREAM_STATE_IDLE: The stream is idle. This can mean two things. The stream specified by <code>strm_handle</code> does not exist or the stream is closed. </li>
<li>AVDTP_STREAM_OPENING_TRANSPORT_CHANNELS: The stream is opening transport channels. </li>
<li>AVDTP_STREAM_CLOSING_TRANSPORT_CHANNELS: The stream is closing transport channels. </li>
<li>AVDTP_STREAM_STATE_CONFIGURED: The stream has been configured. </li>
<li>AVDTP_STREAM_STATE_OPEN: The stream has been opened. </li>
<li>AVDTP_STREAM_STATE_STREAMING: The stream has been started. Depending on the local SEP type (source or sink) it means that the stream is can send or receive media packets. </li>
<li>AVDTP_STREAM_STATE_CLOSING: The stream is closing. This means that all transport channels associated with the stream are being closed. After they have been closed the stream goes to AVDTP_STREAM_STATE_IDLE state. </li>
<li>AVDTP_STREAM_STATE_ABORTING: The stream is aborting. This means that all transport channels associated with the stream are being closed. After they have been closed the stream goes to AVDTP_STREAM_STATE_IDLE state. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa60d8fb5ced62f92bfa88f93ac7d9040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_listen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sep_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac078d38da081ad5112b5992c66c37c9f">bt_avdtp_listen</a>(mgr-&gt;avdtp_mgr, strm_handle, sep_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for incoming connections. </p>
<p>This function tells a stream that it can use a particular SEP to accept incoming requests to open it. The SEP can be associated with multiple streams but used with only one. The stream has to be closed before the SEP can be used with another stream. For outgoing connections this is not needed. Any SEP can be used with any stream given that the SEP is not already in use by another stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">sep_id</td><td>Local SEP ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga83031dd62c1b4694e5159ff52082768c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_reconfigure_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">caps&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gac3d853c711364c8f50f2d29a758cffcf">bt_avdtp_reconfigure_stream</a>(mgr-&gt;avdtp_mgr, strm_handle, caps)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure stream. </p>
<p>This function tries to change the stream's configuration. For this function to succeed the stream has to be open. As a result of this operation the A2DP_EVT_STREAM_RECONFIGURE_COMPLETED event will be generated. If reconfiguration was a success the <code>evt_param.stream_reconfigure_completed.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise the <code>evt_param.stream_reconfigure_completed.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">caps</td><td>New stream configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf2093746741e62a8c3931e1bf2d6323b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_register_sink</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">caps&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga8fc5552470ee84924d0e5fe300e1ef67">bt_avdtp_register_sep</a>(mgr-&gt;avdtp_mgr, <a class="el" href="group__avdtp.html#ga5f99e5a9c4f03230a3d1648231edf3ed">AVDTP_SEP_TYPE_SINK</a>, caps)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a Sink SEP with the local A2DP manager. </p>
<p>This function is used to add a sink SEP to a list of SEPs supported by the local A2DP entity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">caps</td><td>The capabilities of a SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>ID</code> of a SEP if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5932000482e9cf7aa177499b3f2e6a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_register_source</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">caps&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga8fc5552470ee84924d0e5fe300e1ef67">bt_avdtp_register_sep</a>(mgr-&gt;avdtp_mgr, <a class="el" href="group__avdtp.html#gaad17a1d784c3581a823fbd5bcbe617f8">AVDTP_SEP_TYPE_SOURCE</a>, caps)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a Source SEP with the local A2DP manager. </p>
<p>This function is used to add a source SEP to a list of SEPs supported by the local A2DP entity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">caps</td><td>The capabilities of a SEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>ID</code> of a SEP if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga45c2673e6b92dba672c28dc084b39741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_remove_media_rx_buffer</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga30ac93f097aa119c492c1e82bdb083bf">bt_avdtp_remove_media_rx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a media packet buffer from a receive queue. </p>
<p>The consumer of A2DP is responsible for allocating and supplying A2DP with buffers used to store received packets. A2DP itself only has a queue for storing pointers to buffers supplied by the consumer. When a packet comes in A2DP finds the first buffer large enough to hold the received packet, copies the packet to the buffer and generates a A2DP_EVT_MEDIA_PACKET_RECEIVED event. The consumer then has to process the data in the buffer and return it back to the queue. If there is no buffers in the queue or none of the buffers is large enough the received packets is dropped. Each buffer has a field (data_len) that holds the length of the received buffer. This field is never 0 if the buffer contains a packet. If a channel closed regardless of what has caused that and there are still buffers in the queue A2DP generates a A2DP_EVT_MEDIA_PACKET_RECEIVED event for each buffer and sets the data_len to 0. This is to inform the A2DP consumer that the buffer has not been used and can be, for example, deallocated. This function removes a buffer from the receive queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa14adc22169f6c3d48d160f3427c88bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_remove_media_tx_buffer</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#ga3cfff55df797f6d235f9ad5a8313a608">bt_avdtp_remove_media_tx_buffer</a>(mgr-&gt;avdtp_mgr, strm_handle, buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a media packet buffer from a send queue. </p>
<p>When the consumer of A2DP wants to send a packet to a remote device it calls bt_avdtp_add_media_tx_buffer function. The function adds the packet to a queue and tells A2DP that it has something to send. The packet will be send as soon as the stream goes to A2DP_STREAM_STATE_STREAMING state. The consumer has a chance to remove a packet from the queue before it has been sent to a remote device by calling <a class="el" href="group__a2dp.html#gaa14adc22169f6c3d48d160f3427c88bf" title="Remove a media packet buffer from a send queue. ">bt_a2dp_remove_media_tx_buffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a structure that holds the buffer and its parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. The function fails only if a stream specified by the <code>strm_handle</code> parameter </li>
<li>does not exist. The stream can be in any state to call this function.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has not been implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52af0a8b6815b2b00767edd7e73c6cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_start_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gae463a1e025414d880c758865b5d34443">bt_avdtp_start_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a stream. </p>
<p>This function tries to start a stream by sending a request to the remote party. The stream has to be in AVDTP_STREAM_STATE_OPEN state. The stream goes to this state as a result of successful configuration or suspension (both can be initiated by either party). As a result of this operation the A2DP_EVT_START_STREAM_COMPLETED event will be generated. If the stream has been open the <code>evt_param.start_stream_requested.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to start the stream, the <code>evt_param.start_stream_requested.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4e1cb8ff862d38c1520a089945bf8622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_a2dp_suspend_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__avdtp.html#gad180fe6c3657b0fc2367faaf33146e80">bt_avdtp_suspend_stream</a>(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a stream. </p>
<p>This function tries to suspend a stream by sending a request to the remote party. The stream has to be in AVDTP_STREAM_STATE_STREAMING state. As a result of this operation the A2DP_EVT_SUSPEND_STREAM_COMPLETED event will be generated. If the stream has been suspended the <code>evt_param.bt_avdtp_evt_suspend_stream_requested_t.err_code</code> == AVDTP_ERROR_SUCCESS. Otherwise, if the remote device for any reason cannot or does not wish to suspend the stream, the <code>evt_param.bt_avdtp_evt_suspend_stream_requested_t.err_code</code> == the error code sent by the remote.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds, i.e. the actual request has been sent to the remote party. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga059e4d447d77f8c988a90c05212625b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bt_avdtp_get_stream_config</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mgr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strm_handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;bt_avdtp_get_stream_config(mgr-&gt;avdtp_mgr, strm_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream's configuration. </p>
<p>This function returns a pointer to a structure holding current configuration of the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The stream's configuration if strm_handle specifies a valid stream and the stream is in one of the following state: <pre class="fragment">    AVDTP_STREAM_STATE_CONFIGURED
    AVDTP_STREAM_STATE_OPEN
    AVDTP_STREAM_STATE_STREAMING

    \li NULL otherwise.</pre> </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf83cd7be39b6efef38709edb06300c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* bt_a2dp_find_server_callback_fp) (bt_uint supported_features, bt_bool found, void *param)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the application of the result of searching for a remote A2DP entity (sourse or sink) </p>
<p>This function is called by the A2DP layer when searching for an A2DP entity on a remote device has completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supported_features</td><td>Features supported by a remote A2DP entity. </td></tr>
    <tr><td class="paramname">found</td><td><code>TRUE</code> if an A2DP entity has been found on the remote device. <code>FALSE</code> otherwise. </td></tr>
    <tr><td class="paramname">param</td><td>pointer to arbitrary data passed to the <a class="el" href="group__a2dp.html#ga3bb544c351fa0f4352baf4bd1506b893" title="Find source. ">bt_a2dp_find_source()</a> or bt_a2dp_find_sink function through its <code>callback_param</code> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae663c35c177fba748f5f86c6ea801b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* bt_a2dp_mgr_callback_fp) (bt_a2dp_mgr_t *mgr, bt_byte evt, bt_a2dp_event_t *evt_param, void *callback_param)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A2DP application callback. </p>
<p>In order to be notified of various events a consumer of the A2DP layer has to register a callback function. The stack will call that function whenever a new event has been generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager.</td></tr>
    <tr><td class="paramname">evt</td><td>A2DP event. The event can be one of the following values: <ul>
<li>A2DP_EVT_CTRL_CHANNEL_CONNECTED: Control channel connected. </li>
<li>A2DP_EVT_CTRL_CHANNEL_DISCONNECTED: Control channel disconnected. </li>
<li>A2DP_EVT_CTRL_CONNECTION_FAILED: Control channel connection failed (generated only if control connection has been initiated by the local device). </li>
<li>A2DP_EVT_DISCOVER_COMPLETED: Local device completed discovering remote SEPs. </li>
<li>A2DP_EVT_GET_SEP_CAPABILITIES_COMPLETED: Local device received a response to Get SEP capabilities operation. </li>
<li>A2DP_EVT_SET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Set stream configuration operation. </li>
<li>A2DP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Get stream configuration operation. </li>
<li>A2DP_EVT_STREAM_RECONFIGURE_COMPLETED: Local device received a response to Reconfigure stream operation. </li>
<li>A2DP_EVT_OPEN_STREAM_COMPLETED: Local device received a response to Open stream operation. </li>
<li>A2DP_EVT_START_STREAM_COMPLETED: Local device received a response to Start stream operation. </li>
<li>A2DP_EVT_CLOSE_STREAM_COMPLETED: Local device received a response to Close stream operation. </li>
<li>A2DP_EVT_SUSPEND_STREAM_COMPLETED: Local device received a response to Suspend stream operation. </li>
<li>A2DP_EVT_STREAM_SECURITY_CONTROL_COMPLETED: Local device received a response to Stream security control operation. </li>
<li>A2DP_EVT_ABORT_STREAM_COMPLETED: Local device received a response to Abort stream operation. </li>
<li>A2DP_EVT_SEP_INFO_RECEIVED: SEP information received. </li>
<li>A2DP_EVT_SEP_CAPABILITIES_RECEIVED: SEP capabilities received. </li>
<li>A2DP_EVT_STREAM_CONFIGURATION_RECEIVED: Stream configuration received.</li>
</ul>
<ul>
<li>A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED: Remote device requested stream configuration. </li>
<li>A2DP_EVT_OPEN_STREAM_REQUESTED: Remote device requested to open a stream. </li>
<li>A2DP_EVT_START_STREAM_REQUESTED: Remote device requested to start a stream. </li>
<li>A2DP_EVT_CLOSE_STREAM_REQUESTED: Remote device requested to close a stream. </li>
<li>A2DP_EVT_SUSPEND_STREAM_REQUESTED: Remote device requested to suspend a stream. </li>
<li>A2DP_EVT_ABORT_STREAM_REQUESTED: Remote device requested to abort a stream. </li>
<li>A2DP_EVT_RECONFIGURE_STREAM_REQUESTED: Remote device requested to reconfigure a stream. </li>
<li>A2DP_EVT_MEDIA_PACKET_RECEIVED: Remote device sent a media packet. </li>
<li>A2DP_EVT_STREAM_CONFIGURED: A stream has been configured (This event is generated right after A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_RECONFIGURED: A stream has been re-configured (This event is generated right after A2DP_EVT_RECONFIGURE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_OPENED: A stream has been opened (This event is generated as a result of local or remote stream opening request). </li>
<li>A2DP_EVT_STREAM_STARTED: A stream has been started (This event is generated right after A2DP_EVT_START_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_CLOSED: A stream has been close (This event is generated right after A2DP_EVT_CLOSE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_SUSPENDED: A stream has been suspended (This event is generated right after A2DP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_ABORTED: A stream has been aborted (This event is generated right after A2DP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request. It is also generated if connection between devices has been terminated by means other than AVDTP signaling, e.g. devices going out of rage). </li>
<li>A2DP_EVT_MEDIA_PACKET_SENT: The local device has successfully sent a media packet to the remote device. </li>
<li>A2DP_EVT_MEDIA_PACKET_SEND_FAILED: The local device was not able to send a media packet to the remote device.</li>
</ul>
<ul>
<li>A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED Local device completed "open and start" request.</li>
</ul>
</td></tr>
    <tr><td class="paramname">evt_param</td><td>Event parameter. Which member of the bt_a2dp_event_t union is valid depends on the event: <ul>
<li>A2DP_EVT_CTRL_CHANNEL_CONNECTED: <code><a class="el" href="structbt__avdtp__evt__ctrl__channel__connected__t.html" title="Parameter to AVDTP_EVT_CTRL_CHANNEL_CONNECTED event. ">bt_avdtp_evt_ctrl_channel_connected_t</a></code> ctrl_channel_connected </li>
<li>A2DP_EVT_CTRL_CHANNEL_DISCONNECTED: <code><a class="el" href="structbt__avdtp__evt__ctrl__channel__disconnected__t.html" title="Parameter to AVDTP_EVT_CTRL_CHANNEL_DISCONNECTED event. ">bt_avdtp_evt_ctrl_channel_disconnected_t</a></code> ctrl_channel_disconnected </li>
<li>A2DP_EVT_CTRL_CONNECTION_FAILED: <code>NULL</code> </li>
<li>A2DP_EVT_DISCOVER_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__discover__completed__t.html" title="Parameter to AVDTP_EVT_DISCOVER_COMPLETED event. ">bt_avdtp_evt_discover_completed_t</a></code> discover_completed; </li>
<li>A2DP_EVT_GET_SEP_CAPABILITIES_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__get__sep__capabilities__completed__t.html" title="Parameter to AVDTP_EVT_GET_SEP_CAPABILITIES_COMPLETED event. ">bt_avdtp_evt_get_sep_capabilities_completed_t</a></code> get_sep_capabilities_completed </li>
<li>A2DP_EVT_SET_STREAM_CONFIGURATION_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__set__stream__configuration__completed__t.html" title="Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event. ">bt_avdtp_evt_set_stream_configuration_completed_t</a></code> set_stream_configuration_completed </li>
<li>A2DP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__get__stream__configuration__completed__t.html" title="Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_COMPLETED event. ">bt_avdtp_evt_get_stream_configuration_completed_t</a></code> get_stream_configuration_completed </li>
<li>A2DP_EVT_STREAM_RECONFIGURE_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__stream__reconfigure__completed__t.html" title="Parameter to AVDTP_EVT_STREAM_RECONFIGURE_COMPLETED event. ">bt_avdtp_evt_stream_reconfigure_completed_t</a></code> stream_reconfigure_completed </li>
<li>A2DP_EVT_OPEN_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__open__stream__completed__t.html" title="Parameter to AVDTP_EVT_OPEN_STREAM_COMPLETED event. ">bt_avdtp_evt_open_stream_completed_t</a></code> open_stream_completed </li>
<li>A2DP_EVT_START_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__start__stream__completed__t.html" title="Parameter to AVDTP_EVT_START_STREAM_COMPLETED event. ">bt_avdtp_evt_start_stream_completed_t</a></code> start_stream_completed </li>
<li>A2DP_EVT_CLOSE_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__close__stream__completed__t.html" title="Parameter to AVDTP_EVT_CLOSE_STREAM_COMPLETED event. ">bt_avdtp_evt_close_stream_completed_t</a></code> close_stream_completed </li>
<li>A2DP_EVT_SUSPEND_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__suspend__stream__completed__t.html" title="Parameter to AVDTP_EVT_SUSPEND_STREAM_COMPLETED event. ">bt_avdtp_evt_suspend_stream_completed_t</a></code> suspend_stream_completed </li>
<li>A2DP_EVT_STREAM_SECURITY_CONTROL_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__stream__security__control__completed__t.html" title="Parameter to AVDTP_EVT_STREAM_SECURITY_CONTROL_COMPLETED event. ">bt_avdtp_evt_stream_security_control_completed_t</a></code> security_control_completed </li>
<li>A2DP_EVT_ABORT_STREAM_COMPLETED: <code><a class="el" href="structbt__avdtp__evt__abort__stream__requested__t.html" title="Parameter to AVDTP_EVT_ABORT_STREAM_REQUESTED event. ">bt_avdtp_evt_abort_stream_requested_t</a></code> abort_stream_requested </li>
<li>A2DP_EVT_SEP_INFO_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__sep__info__received__t.html" title="Parameter to AVDTP_EVT_SEP_INFO_RECEIVED event. ">bt_avdtp_evt_sep_info_received_t</a></code> sep_info_received </li>
<li>A2DP_EVT_SEP_CAPABILITIES_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__sep__capabilities__received__t.html" title="Parameter to AVDTP_EVT_SEP_CAPABILITIES_RECEIVED and AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED events...">bt_avdtp_evt_sep_capabilities_received_t</a></code> sep_capabilities_received </li>
<li>A2DP_EVT_STREAM_CONFIGURATION_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__sep__capabilities__received__t.html" title="Parameter to AVDTP_EVT_SEP_CAPABILITIES_RECEIVED and AVDTP_EVT_STREAM_CONFIGURATION_RECEIVED events...">bt_avdtp_evt_sep_capabilities_received_t</a></code> sep_capabilities_received</li>
</ul>
<ul>
<li>A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__set__stream__configuration__requested__t.html" title="Parameter to AVDTP_EVT_SET_STREAM_CONFIGURATION_REQUESTED event. ">bt_avdtp_evt_set_stream_configuration_requested_t</a></code> set_stream_configuration_requested </li>
<li>A2DP_EVT_OPEN_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__open__stream__requested__t.html" title="Parameter to AVDTP_EVT_OPEN_STREAM_REQUESTED event. ">bt_avdtp_evt_open_stream_requested_t</a></code> open_stream_requested </li>
<li>A2DP_EVT_START_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__start__stream__requested__t.html" title="Parameter to AVDTP_EVT_START_STREAM_REQUESTED event. ">bt_avdtp_evt_start_stream_requested_t</a></code> start_stream_requested </li>
<li>A2DP_EVT_CLOSE_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__close__stream__requested__t.html" title="Parameter to AVDTP_EVT_CLOSE_STREAM_REQUESTED event. ">bt_avdtp_evt_close_stream_requested_t</a></code> close_stream_requested </li>
<li>A2DP_EVT_SUSPEND_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__suspend__stream__requested__t.html" title="Parameter to AVDTP_EVT_SUSPEND_STREAM_REQUESTED event. ">bt_avdtp_evt_suspend_stream_requested_t</a></code> suspend_stream_requested </li>
<li>A2DP_EVT_ABORT_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__abort__stream__requested__t.html" title="Parameter to AVDTP_EVT_ABORT_STREAM_REQUESTED event. ">bt_avdtp_evt_abort_stream_requested_t</a></code> abort_stream_requested </li>
<li>A2DP_EVT_RECONFIGURE_STREAM_REQUESTED: <code><a class="el" href="structbt__avdtp__evt__reconfigure__stream__requested__t.html" title="Parameter to AVDTP_EVT_RECONFIGURE_STREAM_REQUESTED event. ">bt_avdtp_evt_reconfigure_stream_requested_t</a></code> reconfigure_stream_requested </li>
<li>A2DP_EVT_MEDIA_PACKET_RECEIVED: <code><a class="el" href="structbt__avdtp__evt__media__packet__received__t.html" title="Parameter to AVDTP_EVT_MEDIA_PACKET_RECEIVED event. ">bt_avdtp_evt_media_packet_received_t</a></code> media_packet_received </li>
<li>A2DP_EVT_STREAM_CONFIGURED: <code><a class="el" href="structbt__avdtp__evt__stream__configured__t.html" title="Parameter to AVDTP_EVT_STREAM_CONFIGURED event. ">bt_avdtp_evt_stream_configured_t</a></code> stream_configured </li>
<li>A2DP_EVT_STREAM_RECONFIGURED: <code><a class="el" href="structbt__avdtp__evt__stream__reconfigured__t.html" title="Parameter to AVDTP_EVT_STREAM_RECONFIGURED event. ">bt_avdtp_evt_stream_reconfigured_t</a></code> stream_reconfigured </li>
<li>A2DP_EVT_STREAM_OPENED: <code><a class="el" href="structbt__avdtp__evt__stream__opened__t.html" title="Parameter to AVDTP_EVT_STREAM_OPENED event. ">bt_avdtp_evt_stream_opened_t</a></code> stream_opened </li>
<li>A2DP_EVT_STREAM_STARTED: <code><a class="el" href="structbt__avdtp__evt__stream__started__t.html" title="Parameter to AVDTP_EVT_STREAM_STARTED event. ">bt_avdtp_evt_stream_started_t</a></code> stream_started </li>
<li>A2DP_EVT_STREAM_CLOSED: <code><a class="el" href="structbt__avdtp__evt__stream__closed__t.html" title="Parameter to AVDTP_EVT_STREAM_CLOSED event. ">bt_avdtp_evt_stream_closed_t</a></code> stream_closed </li>
<li>A2DP_EVT_STREAM_SUSPENDED: <code><a class="el" href="structbt__avdtp__evt__stream__suspended__t.html" title="Parameter to AVDTP_EVT_STREAM_SUSPENDED event. ">bt_avdtp_evt_stream_suspended_t</a></code> stream_suspended </li>
<li>A2DP_EVT_STREAM_ABORTED: <code><a class="el" href="structbt__avdtp__evt__stream__aborted__t.html" title="Parameter to AVDTP_EVT_STREAM_ABORTED event. ">bt_avdtp_evt_stream_aborted_t</a></code> stream_aborted </li>
<li>A2DP_EVT_MEDIA_PACKET_SENT: <code><a class="el" href="structbt__avdtp__evt__media__packet__sent__t.html" title="Parameter to AVDTP_EVT_MEDIA_PACKET_SENT event. ">bt_avdtp_evt_media_packet_sent_t</a></code> media_packet_sent </li>
<li>A2DP_EVT_MEDIA_PACKET_SEND_FAILED: <code><a class="el" href="structbt__avdtp__evt__media__packet__send__failed__t.html" title="Parameter to AVDTP_EVT_MEDIA_PACKET_SEND_FAILED event. ">bt_avdtp_evt_media_packet_send_failed_t</a></code> media_packet_send_failed</li>
</ul>
<ul>
<li>A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED <code><a class="el" href="structbt__a2dp__evt__open__and__start__stream__completed__t.html" title="Parameter to A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED event. ">bt_a2dp_evt_open_and_start_stream_completed_t</a></code> open_and_start_stream_completed</li>
</ul>
</td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to an arbitrary data set by a call to bt_avdtp_register_callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafb588e20fd7bcf48c07223b35955e516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_a2dp_find_sink </td>
          <td>(</td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>deviceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__a2dp.html#gaf83cd7be39b6efef38709edb06300c33">bt_a2dp_find_server_callback_fp</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_sdp_client_callback_fp&#160;</td>
          <td class="paramname"><em>client_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find sink. </p>
<p>This function looks for a sink on a remote device specified by <code>deviceAddress</code> and, if found, returns features supported by the sink.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceAddress</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when search has completed. </td></tr>
    <tr><td class="paramname">client_callback</td><td>The optional callback function that an application can set if it wants to be notified of state changes of the SDP client. The <code>evt</code> parameter of the callback can be one of the following values: <ul>
<li>SDP_CLIENT_STATE_IDLE </li>
<li>SDP_CLIENT_STATE_CONNECTING </li>
<li>SDP_CLIENT_STATE_DISCONNECTING </li>
<li>SDP_CLIENT_STATE_CONNECTED</li>
</ul>
</td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> and <code>client_callback</code> callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3bb544c351fa0f4352baf4bd1506b893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_a2dp_find_source </td>
          <td>(</td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>deviceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__a2dp.html#gaf83cd7be39b6efef38709edb06300c33">bt_a2dp_find_server_callback_fp</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_sdp_client_callback_fp&#160;</td>
          <td class="paramname"><em>client_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find source. </p>
<p>This function looks for a source on a remote device specified by <code>deviceAddress</code> and, if found, returns features supported by the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceAddress</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when search has completed. </td></tr>
    <tr><td class="paramname">client_callback</td><td>The optional callback function that an application can set if it wants to be notified of state changes of the SDP client. The <code>evt</code> parameter of the callback can be one of the following values: <ul>
<li>SDP_CLIENT_STATE_IDLE </li>
<li>SDP_CLIENT_STATE_CONNECTING </li>
<li>SDP_CLIENT_STATE_DISCONNECTING </li>
<li>SDP_CLIENT_STATE_CONNECTED</li>
</ul>
</td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> and <code>client_callback</code> callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6cb7a99f3f0b5be9cfa4189bd69b70ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_a2dp_mgr_t* bt_a2dp_get_mgr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to an instance of the A2DP manager. </p>
<p>This function returns a pointer to an instance of the A manager. There is only one instance of the manager allocated by the stack. The pointer is passed as the first parameter to all A2DP functions. </p>

</div>
</div>
<a class="anchor" id="ga139524ac4af24814dc117a7650ee764f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_a2dp_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the A2DP layer. </p>
<p>This function initializes the A2DP layer of the stack. It must be called prior to any other A2DP function can be called. </p>

</div>
</div>
<a class="anchor" id="ga69a19ef7a50b8a773b33a408d566d08f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_a2dp_open_and_start_stream </td>
          <td>(</td>
          <td class="paramtype">bt_a2dp_mgr_t *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>strm_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_bdaddr_t *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>seid_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>seid_acp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbt__avdtp__sep__capabilities__t.html">bt_avdtp_sep_capabilities_t</a> *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open &amp; start a stream. </p>
<p>Opening a stream involves sending 3 requests to a remote device - "set configuration", "open stream" and "start stream". Each event generates its own event which must be handled and acted accordingly by the application. To make the use of API easier dotstack combines all these requests in one request called "open &amp; start stream". dotstack sends necessary requests in a proper sequence, handles responses and generates only one event (A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED) at the end. If any of the individual requests has failed the event's parameter bt_a2dp_event_t::open_and_start_stream_completed is populated with the error code and request id which caused it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
    <tr><td class="paramname">strm_handle</td><td>Stream handle. </td></tr>
    <tr><td class="paramname">remote_addr</td><td>The address of a remote device. </td></tr>
    <tr><td class="paramname">seid_int</td><td>Local SEP ID. </td></tr>
    <tr><td class="paramname">seid_acp</td><td>Remote SEP ID. </td></tr>
    <tr><td class="paramname">caps</td><td>Stream configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. No events will be generated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga66951e65e952cda647a590927e048d61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_a2dp_register_aac_codec </td>
          <td>(</td>
          <td class="paramtype">bt_a2dp_mgr_t *&#160;</td>
          <td class="paramname"><em>mgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register default AAC codec. </p>
<p>This function adds AAC codec implemented by dotstack to the list of known codecs. For more information about codecs see description of <a class="el" href="group__avdtp.html#ga35b9313048cf22068276f9dc5505debb" title="Register a codec. ">bt_avdtp_register_codec</a>. The only codec A2DP is mandatory to support is SBC. All other codecs are optional. If an application wants to use AAC codec it must call this function when it is initializing.</p>
<dl class="section note"><dt>Note</dt><dd>dotstack codecs do not do actual encoding/decoding. their function is to parse and serialize codec's configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac85b20ac54765375b53f76325937c126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_a2dp_register_callback </td>
          <td>(</td>
          <td class="paramtype">bt_a2dp_mgr_t *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__a2dp.html#gae663c35c177fba748f5f86c6ea801b8f">bt_a2dp_mgr_callback_fp</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a A2DP application callback. </p>
<p>In order to be notified of various events a consumer of the A2DP layer has to register a callback function. The stack will call this function whenever a new event has been generated passing the code of the event as the second parameter. The event can be one of the following values:</p>
<ul>
<li>A2DP_EVT_CTRL_CHANNEL_CONNECTED: Control channel connected. </li>
<li>A2DP_EVT_CTRL_CHANNEL_DISCONNECTED: Control channel disconnected. </li>
<li>A2DP_EVT_CTRL_CONNECTION_FAILED: Control channel connection failed (generated only if control connection has been initiated by the local device). </li>
<li>A2DP_EVT_DISCOVER_COMPLETED: Local device completed discovering remote SEPs. </li>
<li>A2DP_EVT_GET_SEP_CAPABILITIES_COMPLETED: Local device received a response to Get SEP capabilities operation. </li>
<li>A2DP_EVT_SET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Set stream configuration operation. </li>
<li>A2DP_EVT_GET_STREAM_CONFIGURATION_COMPLETED: Local device received a response to Get stream configuration operation. </li>
<li>A2DP_EVT_STREAM_RECONFIGURE_COMPLETED: Local device received a response to Reconfigure stream operation. </li>
<li>A2DP_EVT_OPEN_STREAM_COMPLETED: Local device received a response to Open stream operation. </li>
<li>A2DP_EVT_START_STREAM_COMPLETED: Local device received a response to Start stream operation. </li>
<li>A2DP_EVT_CLOSE_STREAM_COMPLETED: Local device received a response to Close stream operation. </li>
<li>A2DP_EVT_SUSPEND_STREAM_COMPLETED: Local device received a response to Suspend stream operation. </li>
<li>A2DP_EVT_STREAM_SECURITY_CONTROL_COMPLETED: Local device received a response to Stream security control operation. </li>
<li>A2DP_EVT_ABORT_STREAM_COMPLETED: Local device received a response to Abort stream operation. </li>
<li>A2DP_EVT_SEP_INFO_RECEIVED: SEP information received. </li>
<li>A2DP_EVT_SEP_CAPABILITIES_RECEIVED: SEP capabilities received. </li>
<li>A2DP_EVT_STREAM_CONFIGURATION_RECEIVED: Stream configuration received.</li>
</ul>
<ul>
<li>A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED: Remote device requested stream configuration. </li>
<li>A2DP_EVT_OPEN_STREAM_REQUESTED: Remote device requested to open a stream. </li>
<li>A2DP_EVT_START_STREAM_REQUESTED: Remote device requested to start a stream. </li>
<li>A2DP_EVT_CLOSE_STREAM_REQUESTED: Remote device requested to close a stream. </li>
<li>A2DP_EVT_SUSPEND_STREAM_REQUESTED: Remote device requested to suspend a stream. </li>
<li>A2DP_EVT_ABORT_STREAM_REQUESTED: Remote device requested to abort a stream. </li>
<li>A2DP_EVT_RECONFIGURE_STREAM_REQUESTED: Remote device requested to reconfigure a stream. </li>
<li>A2DP_EVT_MEDIA_PACKET_RECEIVED: Remote device sent a media packet. </li>
<li>A2DP_EVT_STREAM_CONFIGURED: A stream has been configured (This event is generated right after A2DP_EVT_SET_STREAM_CONFIGURATION_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_RECONFIGURED: A stream has been re-configured (This event is generated right after A2DP_EVT_RECONFIGURE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_OPENED: A stream has been opened (This event is generated as a result of local or remote stream opening request). </li>
<li>A2DP_EVT_STREAM_STARTED: A stream has been started (This event is generated right after A2DP_EVT_START_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_CLOSED: A stream has been close (This event is generated right after A2DP_EVT_CLOSE_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_SUSPENDED: A stream has been suspended (This event is generated right after A2DP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request). </li>
<li>A2DP_EVT_STREAM_ABORTED: A stream has been aborted (This event is generated right after A2DP_EVT_SUSPEND_STREAM_REQUESTED if the local devices accepted the request. It is also generated if connection between devices has been terminated by means other than A2DP signaling, e.g. devices going out of range). </li>
<li>A2DP_EVT_MEDIA_PACKET_SENT: The local device has successfully sent a media packet to the remote device. </li>
<li>A2DP_EVT_MEDIA_PACKET_SEND_FAILED: The local device was not able to send a media packet to the remote device.</li>
</ul>
<ul>
<li>A2DP_EVT_OPEN_AND_START_STREAM_COMPLETED This event is generated when a local device completed "open and start" request.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when the AVDTP generates an event. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab2a2d71e2023013f27899ddeefa77c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_a2dp_register_mpeg_codec </td>
          <td>(</td>
          <td class="paramtype">bt_a2dp_mgr_t *&#160;</td>
          <td class="paramname"><em>mgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register default MPEG codec. </p>
<p>This function adds MPEG codec implemented by dotstack to the list of known codecs. For more information about codecs see description of <a class="el" href="group__avdtp.html#ga35b9313048cf22068276f9dc5505debb" title="Register a codec. ">bt_avdtp_register_codec</a>. The only codec A2DP is mandatory to support is SBC. All other codecs are optional. If an application wants to use MPEG-1,2 codec it must call this function when it is initializing.</p>
<dl class="section note"><dt>Note</dt><dd>dotstack codecs do not do actual encoding/decoding. their function is to parse and serialize codec's configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>A2DP manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae184ae7ff523a3fb0557b324a6a25f42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool bt_a2dp_start </td>
          <td>(</td>
          <td class="paramtype">bt_a2dp_mgr_t *&#160;</td>
          <td class="paramname"><em>mgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the A2DP layer. </p>
<p>This function makes the A2DP layer ready to accept connection requests from remote device. To make an outgoing connection calling this function is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>AVDTP manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>TRUE</code> if the function succeeds. </li>
<li><code>FALSE</code> otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>Copyright &copy; 2015 SEARAN LLC. All right reserved.</small></address>
</body>
</html>
