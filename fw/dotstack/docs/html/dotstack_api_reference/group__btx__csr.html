<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>dotstack API Reference: CSR</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dotstack API Reference
   &#160;<span id="projectnumber">1.8.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CSR<div class="ingroups"><a class="el" href="group__btx.html">Vendor specific extensions to HCI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaafb273156b29af3f08bf0960eddc7637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#gaafb273156b29af3f08bf0960eddc7637">btx_csr_init</a> (void)</td></tr>
<tr class="memdesc:gaafb273156b29af3f08bf0960eddc7637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CSR support layer.  <a href="#gaafb273156b29af3f08bf0960eddc7637">More...</a><br /></td></tr>
<tr class="separator:gaafb273156b29af3f08bf0960eddc7637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbe69a49a88dea57d590a25a41ebf2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga5bbe69a49a88dea57d590a25a41ebf2f">btx_csr_autobaud</a> (btx_csr_autobaud_buffer_t *buffer, btx_csr_autobaud_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga5bbe69a49a88dea57d590a25a41ebf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure controller's UART speed.  <a href="#ga5bbe69a49a88dea57d590a25a41ebf2f">More...</a><br /></td></tr>
<tr class="separator:ga5bbe69a49a88dea57d590a25a41ebf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1939a1a5012a7b063e6a0e41e08f54f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga1939a1a5012a7b063e6a0e41e08f54f9">btx_csr_bc7_sel_host_interface_h4</a> (btx_csr_autobaud_buffer_t *buffer, bt_byte interval, btx_csr_autobaud_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga1939a1a5012a7b063e6a0e41e08f54f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure controller's UART speed and host interface.  <a href="#ga1939a1a5012a7b063e6a0e41e08f54f9">More...</a><br /></td></tr>
<tr class="separator:ga1939a1a5012a7b063e6a0e41e08f54f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675389951d418a7cafe94e14197665d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga675389951d418a7cafe94e14197665d5">btx_csr_exec_script</a> (const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *script, btx_csr_exec_script_buffer_t *buffer, btx_csr_exec_script_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga675389951d418a7cafe94e14197665d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch controller's firmware.  <a href="#ga675389951d418a7cafe94e14197665d5">More...</a><br /></td></tr>
<tr class="separator:ga675389951d418a7cafe94e14197665d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7986151be07a5dfc138c9e9fe672f64b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga7986151be07a5dfc138c9e9fe672f64b">btx_csr_set_ps_vars</a> (const bt_uint *ps_vars, btx_csr_set_ps_vars_buffer_t *buffer, btx_csr_set_ps_vars_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga7986151be07a5dfc138c9e9fe672f64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PS variables.  <a href="#ga7986151be07a5dfc138c9e9fe672f64b">More...</a><br /></td></tr>
<tr class="separator:ga7986151be07a5dfc138c9e9fe672f64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed825fbffd312a30d063bac2c04bfd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga9ed825fbffd312a30d063bac2c04bfd8">btx_csr_set_ps_vars_ex</a> (const bt_uint *ps_vars, btx_csr_set_ps_vars_buffer_t *buffer, bt_uint store, btx_csr_set_ps_vars_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga9ed825fbffd312a30d063bac2c04bfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PS variables.  <a href="#ga9ed825fbffd312a30d063bac2c04bfd8">More...</a><br /></td></tr>
<tr class="separator:ga9ed825fbffd312a30d063bac2c04bfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f821685f304c07a63edfd64c6d0d2a"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#gaf0f821685f304c07a63edfd64c6d0d2a">btx_csr_warm_reset</a> (void)</td></tr>
<tr class="memdesc:gaf0f821685f304c07a63edfd64c6d0d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warm reset.  <a href="#gaf0f821685f304c07a63edfd64c6d0d2a">More...</a><br /></td></tr>
<tr class="separator:gaf0f821685f304c07a63edfd64c6d0d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90805680606bbd16d5f36718bffd3e10"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga90805680606bbd16d5f36718bffd3e10">btx_csr_warm_reset_ex</a> (bt_hci_cmd_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga90805680606bbd16d5f36718bffd3e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warm reset.  <a href="#ga90805680606bbd16d5f36718bffd3e10">More...</a><br /></td></tr>
<tr class="separator:ga90805680606bbd16d5f36718bffd3e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cea0e378b233671654a300d5a45c110"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga0cea0e378b233671654a300d5a45c110">btx_csr_enable_tx</a> (bt_bool enable, bt_hci_cmd_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga0cea0e378b233671654a300d5a45c110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable transmitter.  <a href="#ga0cea0e378b233671654a300d5a45c110">More...</a><br /></td></tr>
<tr class="separator:ga0cea0e378b233671654a300d5a45c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6fde94b192974feac2b17772797216"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#gaec6fde94b192974feac2b17772797216">btx_csr_get_cached_temperature</a> (btx_csr_get_var_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:gaec6fde94b192974feac2b17772797216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get chip's cached temperature.  <a href="#gaec6fde94b192974feac2b17772797216">More...</a><br /></td></tr>
<tr class="separator:gaec6fde94b192974feac2b17772797216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1477ed8fbee0fe9e50a02cfb622b9ac6"><td class="memItemLeft" align="right" valign="top">bt_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga1477ed8fbee0fe9e50a02cfb622b9ac6">btx_csr_get_rssi_acl</a> (bt_hci_hconn_t hconn, btx_csr_get_var_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga1477ed8fbee0fe9e50a02cfb622b9ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RSSI.  <a href="#ga1477ed8fbee0fe9e50a02cfb622b9ac6">More...</a><br /></td></tr>
<tr class="separator:ga1477ed8fbee0fe9e50a02cfb622b9ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21dd1b24cdebff8cf93aa3ded3ccaca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga21dd1b24cdebff8cf93aa3ded3ccaca5">btx_csr_patch_controller</a> (const btx_csr_get_script_fp *scripts, bt_int script_count, btx_csr_exec_script_buffer_t *buffer, btx_csr_exec_script_callback_fp callback, void *callback_param)</td></tr>
<tr class="memdesc:ga21dd1b24cdebff8cf93aa3ded3ccaca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch controller's firmware.  <a href="#ga21dd1b24cdebff8cf93aa3ded3ccaca5">More...</a><br /></td></tr>
<tr class="separator:ga21dd1b24cdebff8cf93aa3ded3ccaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ea43474d67077d350a4c1fe699c13b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95ea43474d67077d350a4c1fe699c13b"></a>
const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga95ea43474d67077d350a4c1fe699c13b">btx_csr_get_script__PB_27_R20_BC6ROM_A04</a> (void)</td></tr>
<tr class="memdesc:ga95ea43474d67077d350a4c1fe699c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return script for patching BlueCore 6. <br /></td></tr>
<tr class="separator:ga95ea43474d67077d350a4c1fe699c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ed882a5b6245d647685cdb8edd2486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3ed882a5b6245d647685cdb8edd2486"></a>
const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#gab3ed882a5b6245d647685cdb8edd2486">btx_csr_get_script__PB_90_REV6</a> (void)</td></tr>
<tr class="memdesc:gab3ed882a5b6245d647685cdb8edd2486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return script for patching CSR8810 (BlueCore 7) <br /></td></tr>
<tr class="separator:gab3ed882a5b6245d647685cdb8edd2486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d4dfe08ac97cde1b68d55ee34cebc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80d4dfe08ac97cde1b68d55ee34cebc9"></a>
const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga80d4dfe08ac97cde1b68d55ee34cebc9">btx_csr_get_script__PB_101_CSR8811_CSP28_UART</a> (void)</td></tr>
<tr class="memdesc:ga80d4dfe08ac97cde1b68d55ee34cebc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return script for patching CSR8x11 A06 (BlueCore 7) <br /></td></tr>
<tr class="separator:ga80d4dfe08ac97cde1b68d55ee34cebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73738d4d1bc1d4f5b2277cf1dacc3e51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73738d4d1bc1d4f5b2277cf1dacc3e51"></a>
const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#ga73738d4d1bc1d4f5b2277cf1dacc3e51">btx_csr_get_script__PB_109_CSR8811_REV16</a> (void)</td></tr>
<tr class="memdesc:ga73738d4d1bc1d4f5b2277cf1dacc3e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return script for patching CSR8x11 A08 (BlueCore 7) <br /></td></tr>
<tr class="separator:ga73738d4d1bc1d4f5b2277cf1dacc3e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee4af953ee6319ca78597a63604f14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeee4af953ee6319ca78597a63604f14e"></a>
const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#gaeee4af953ee6319ca78597a63604f14e">btx_csr_get_script__dsp_script__PB_109_DSP_rev8</a> (void)</td></tr>
<tr class="memdesc:gaeee4af953ee6319ca78597a63604f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return script for patching DSP in CSR8x11 A08 (BlueCore 7) <br /></td></tr>
<tr class="separator:gaeee4af953ee6319ca78597a63604f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca48668baa81cde4bf4b6a7554113dc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca48668baa81cde4bf4b6a7554113dc1"></a>
const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btx__csr.html#gaca48668baa81cde4bf4b6a7554113dc1">btx_csr_get_script__PB_173_CSR8X11_REV1</a> (void)</td></tr>
<tr class="memdesc:gaca48668baa81cde4bf4b6a7554113dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return script for patching CSR8x11 A12 (BlueCore 7) <br /></td></tr>
<tr class="separator:gaca48668baa81cde4bf4b6a7554113dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5bbe69a49a88dea57d590a25a41ebf2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_autobaud </td>
          <td>(</td>
          <td class="paramtype">btx_csr_autobaud_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_autobaud_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure controller's UART speed. </p>
<p>This function makes the controller auto-configure its UART speed. The host transport must be set to H4. This function works only with BC6 controllers. </p>

</div>
</div>
<a class="anchor" id="ga1939a1a5012a7b063e6a0e41e08f54f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_bc7_sel_host_interface_h4 </td>
          <td>(</td>
          <td class="paramtype">btx_csr_autobaud_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_byte&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_autobaud_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure controller's UART speed and host interface. </p>
<p>This function makes the controller auto-configure its UART speed and select H4 as host interface. PS_KEY_HOST_INTERFACE must not be set. PS_KEY_UART_BITRATE must be set to 0. This function works only with BC7 controllers. </p>

</div>
</div>
<a class="anchor" id="ga0cea0e378b233671654a300d5a45c110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool btx_csr_enable_tx </td>
          <td>(</td>
          <td class="paramtype">bt_bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_hci_cmd_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable transmitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Specifies whether the transmitter should be enable or disabled. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called after the command has completed. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga675389951d418a7cafe94e14197665d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_exec_script </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtx__csr__script__t.html">btx_csr_script_t</a> *&#160;</td>
          <td class="paramname"><em>script</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_exec_script_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_exec_script_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch controller's firmware. </p>
<p>This function executes a script that patches the controller's firmware. The <code>script</code> must point to a structure that contain a complete patch script for a particular controller model and revision. If the revision specified in the script and revision read from the controller are the same <a class="el" href="group__btx__csr.html#ga21dd1b24cdebff8cf93aa3ded3ccaca5" title="Patch controller&#39;s firmware. ">btx_csr_patch_controller()</a> loads the script to the controller and calls the <code>callback</code> with the first parameter TRUE. Otherwise the <code>callback</code> is called with the first parameter FALSE.</p>
<p>If support for multiple firmware revisions is neede use <a class="el" href="group__btx__csr.html#ga21dd1b24cdebff8cf93aa3ded3ccaca5" title="Patch controller&#39;s firmware. ">btx_csr_patch_controller()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">script</td><td>Array of patch scripts. </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer for storing temporary data needed for script execution. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when the script has been executed. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec6fde94b192974feac2b17772797216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool btx_csr_get_cached_temperature </td>
          <td>(</td>
          <td class="paramtype">btx_csr_get_var_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get chip's cached temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function that will be called after the command has completed. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1477ed8fbee0fe9e50a02cfb622b9ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool btx_csr_get_rssi_acl </td>
          <td>(</td>
          <td class="paramtype">bt_hci_hconn_t&#160;</td>
          <td class="paramname"><em>hconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_get_var_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get RSSI. </p>
<p>This function retrieves the RSSI for a given HCI ACL handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hconn</td><td>ACL connection handle. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called after the command has completed. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaafb273156b29af3f08bf0960eddc7637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CSR support layer. </p>
<p>This function initializes all internal variables of the CSR support layer. CSR controllers use vendor specific event (0xFF) to carry the BCCMD protocol. They also do not report number of completed packets for BCCMD commands. This function installs a vendor specific event handler that makes sure that callback are called on corresponding vendor specific commands and the number of free command buffers in the controller is kept correct. </p>

</div>
</div>
<a class="anchor" id="ga21dd1b24cdebff8cf93aa3ded3ccaca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_patch_controller </td>
          <td>(</td>
          <td class="paramtype">const btx_csr_get_script_fp *&#160;</td>
          <td class="paramname"><em>scripts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_int&#160;</td>
          <td class="paramname"><em>script_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_exec_script_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_exec_script_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch controller's firmware. </p>
<p>This function executes a script that patches the controller's firmware. Each entry of the <code>scripts</code> array must be a complete patch script for a particular controller model and revision. <a class="el" href="group__btx__csr.html#ga21dd1b24cdebff8cf93aa3ded3ccaca5" title="Patch controller&#39;s firmware. ">btx_csr_patch_controller()</a> reads the revision number from the controller then tries to find the corresponding script in the <code>scripts</code>. If there is a matching script it is loaded to the controller and <code>callback</code> is called with the first parameter TRUE. If no suitable script found <code>callback</code> is called with the first parameter FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scripts</td><td>Array of patch scripts. </td></tr>
    <tr><td class="paramname">script_count</td><td>The number of scripts in <code>scripts</code>. </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer for storing temporary data needed for script execution. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when the script has been executed. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7986151be07a5dfc138c9e9fe672f64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_set_ps_vars </td>
          <td>(</td>
          <td class="paramtype">const bt_uint *&#160;</td>
          <td class="paramname"><em>ps_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_set_ps_vars_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_set_ps_vars_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write PS variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps_vars</td><td>PS values </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer for storing temporary data during function execution. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when all PS values have been sent to the controller or error occurred. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ed825fbffd312a30d063bac2c04bfd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btx_csr_set_ps_vars_ex </td>
          <td>(</td>
          <td class="paramtype">const bt_uint *&#160;</td>
          <td class="paramname"><em>ps_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_set_ps_vars_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_uint&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btx_csr_set_ps_vars_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write PS variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps_vars</td><td>PS values </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer for storing temporary data during function execution. </td></tr>
    <tr><td class="paramname">store</td><td></td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will be called when all PS values have been sent to the controller or error occurred. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0f821685f304c07a63edfd64c6d0d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool btx_csr_warm_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warm reset. </p>
<p>This function performs warm reset of the controller. All patches and configuration parameters sent to the controller before warm reset are kept intact. </p>

</div>
</div>
<a class="anchor" id="ga90805680606bbd16d5f36718bffd3e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_bool btx_csr_warm_reset_ex </td>
          <td>(</td>
          <td class="paramtype">bt_hci_cmd_callback_fp&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warm reset. </p>
<p>This function performs warm reset of the controller. All patches and configuration parameters sent to the controller before warm reset are kept intact. Since the controller does not respond to the warm reset command as it starts resetting immediately upon receiving the command, the <code>callback</code> is called right after the command packet has been transmitted to the controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function that will be called after the warm reset command has been sent to the controller. </td></tr>
    <tr><td class="paramname">callback_param</td><td>A pointer to arbitrary data to be passed to the <code>callback</code> callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>Copyright &copy; 2015 SEARAN LLC. All right reserved.</small></address>
</body>
</html>
